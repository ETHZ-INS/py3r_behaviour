{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"py3r-behaviour","text":"<p>Post-processing and analysis utilities for behavioural pose-estimation data.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide explains the end\u2011to\u2011end workflow and links to the relevant APIs. It is intentionally minimal and focuses on \u201cwhat\u201d and \u201cwhere,\u201d not code. </p> <p>For detailed methods and syntax examples, see API</p> <p>For code pipeline examples, see Examples</p>"},{"location":"getting_started/#core-objects","title":"Core objects","text":"<ul> <li><code>Tracking</code>: store and preprocess single\u2011view tracked keypoints with auto-generated metadata.</li> <li><code>TrackingMV</code>: like <code>Tracking</code> but with multi\u2011view plus calibration (for 3D).</li> <li><code>Features</code>: (generated from a <code>Tracking</code> object) derive per\u2011frame signals from a single <code>Tracking</code> (e.g. speeds, distances, location booleans, behavioural clusters).</li> <li><code>Summary</code>: (generated from a <code>Features</code> object) derive scalar/statistical results from a single <code>Features</code> (e.g. av speeds, total distances, time in location, behavioural flow analysis stats).</li> </ul>"},{"location":"getting_started/#collections","title":"Collections","text":"<ul> <li><code>TrackingCollection</code>: batch load/process and group <code>Tracking</code> (or <code>TrackingMV</code>) objects.</li> <li><code>FeaturesCollection</code>: (generated from <code>TrackingCollection</code> object) batch process and group <code>Features</code> objects, and perform whole-dataset operations (e.g. behavioural clustering from time-series embeddings).</li> <li><code>SummaryCollection</code>: (generated from <code>FeaturesCollection</code> object) mapping of handle \u2192 <code>Summary</code> with grouping/batch helpers.</li> </ul>"},{"location":"getting_started/#collection-helpers","title":"Collection helpers","text":"<ul> <li><code>.groupby</code> and <code>.flatten</code> allow dynamic reorganisation of collections based on arbitrary subsets of <code>tags</code> assigned to individual elements. Groupings persist when generating e.g. a <code>FeaturesCollection</code> from a <code>TrackingCollection</code></li> <li>flexible collection indexing by handle (e.g. <code>coll['recording1']</code>), integer (e.g. <code>coll[0]</code>) and slice (e.g. <code>coll[0:2]</code>)</li> </ul>"},{"location":"getting_started/#general-helpers","title":"General helpers","text":"<ul> <li>All core objects and collections have <code>.save</code> and <code>.load</code> methods that preserve all data/metadata/groupings</li> <li>Objects and collections allow <code>.loc[]</code> and <code>.iloc[]</code> (batch) slicing and indexing of the DataFrames in all <code>Tracking</code>, <code>TrackingCollection</code>, <code>Features</code> and <code>FeaturesCollection</code> objects</li> </ul>"},{"location":"getting_started/#typical-workflow","title":"Typical workflow","text":"<ol> <li> <p>Load a dataset of single-view tracking files from DeepLabCut: <code>TrackingCollection.from_dlc_folder</code></p> </li> <li> <p>Add tags to each recording (e.g. 'treatment', 'genotype'): <code>TrackingCollection.add_tags_from_csv</code></p> </li> <li> <p>Group the collection by any subset of tags: <code>TrackingCollection.groupby</code> (grouping persists upon <code>FeaturesCollection</code> and <code>SummaryCollection</code> generation)</p> </li> <li> <p>Perform various QA checks:</p> <ol> <li>ensure recording length is as expected: <code>Tracking.time_as_expected</code></li> <li>plot tracked point trajectories: <code>TrackingCollection.plot</code></li> </ol> </li> <li> <p>Perform various batch pre-processing steps: </p> <ol> <li>remove low-likelihood tracked points: <code>Tracking.filter_likelihood</code></li> <li>smooth data: <code>Tracking.smooth_all</code></li> <li>interpolate gaps: <code>Tracking.interpolate</code></li> <li>rescale pixels to metres: <code>Tracking.rescale_by_known_distance</code></li> <li>trim the start/end of the recording: <code>trim</code></li> </ol> </li> <li> <p>Generate a <code>FeaturesCollection</code> object from the <code>TrackingCollection</code>: <code>FeaturesCollection.from_tracking_collection</code></p> </li> <li> <p>Calculate various features and <code>store</code> them with auto-generated names and metadata:</p> <ul> <li>Distance and movement:<ul> <li><code>Features.distance_between</code></li> <li><code>Features.distance_change</code></li> <li><code>Features.speed</code></li> <li><code>Features.acceleration</code></li> </ul> </li> <li>Boundaries and locations:<ul> <li>Define static boundary from tracked points: <code>Features.define_boundary</code></li> <li>Static membership: <code>Features.within_boundary_static</code></li> <li>Dynamic membership: <code>Features.within_boundary_dynamic</code></li> <li>Boundary area: <code>Features.area_of_boundary</code></li> <li>Distance to boundary (static/dynamic): <code>Features.distance_to_boundary_static</code>, <code>Features.distance_to_boundary_dynamic</code></li> </ul> </li> <li>Orientation:<ul> <li><code>Features.azimuth</code></li> <li><code>Features.azimuth_deviation</code></li> <li><code>Features.within_azimuth_deviation</code></li> </ul> </li> <li>Thresholds:<ul> <li><code>Features.above_speed</code>, <code>Features.all_above_speed</code></li> <li><code>Features.below_speed</code>, <code>Features.all_below_speed</code></li> </ul> </li> <li>Embeddings and clustering:<ul> <li>Build time\u2011shifted embeddings: <code>Features.embedding_df</code></li> <li>Batch k\u2011means on embeddings: <code>FeaturesCollection.cluster_embedding</code></li> <li>Assign to precomputed centroids: <code>Features.assign_clusters_by_centroids</code></li> </ul> </li> </ul> </li> <li> <p>Generate a <code>SummaryCollection</code> object from the <code>FeaturesCollection</code>: <code>SummaryCollection.from_features_collection</code></p> </li> <li> <p>Generate summary statistics and export:</p> <ul> <li>Per\u2011recording metrics (batched over the collection): <code>Summary.time_true</code>, <code>Summary.time_false</code>, <code>Summary.total_distance</code>, <code>Summary.transition_matrix</code>, <code>Summary.count_state_onsets</code>, <code>Summary.time_in_state</code></li> <li>Collate scalar outputs into a tidy table: <code>SummaryCollection.to_df</code></li> <li>Behaviour Flow Analysis on grouped collections: <code>SummaryCollection.bfa</code> and post\u2011processing stats via <code>SummaryCollection.bfa_stats</code></li> </ul> </li> </ol>"},{"location":"install/","title":"Install py3r-behaviour","text":""},{"location":"install/#pre-install-requirements","title":"Pre-install requirements","text":"<p>A virtual environment with:</p> <ul> <li>Python &gt;= 3.12 </li> <li>pip &gt;= 21.3 </li> <li>git</li> </ul>"},{"location":"install/#windows","title":"Windows","text":"<p>copy and run this command in Command Prompt or Powershell</p> <pre><code>powershell -Command \"$repo='ETH-INS/py3r_behaviour'; \\\n$latest = Invoke-RestMethod -Uri \\\"https://api.github.com/repos/$repo/releases/latest\\\"; \\\n$tag = $latest.tag_name; \\\npip install --upgrade git+https://github.com/$repo.git@$tag\"\n</code></pre>"},{"location":"install/#linuxmac-os","title":"Linux/Mac OS","text":"<p>copy and run this command in Terminal <pre><code>repo=\"ETH-INS/py3r_behaviour\"\nlatest_tag=$(curl -s https://api.github.com/repos/$repo/releases/latest | grep -Po '\"tag_name\": \"\\K.*?(?=\")')\npip install --upgrade git+https://github.com/$repo.git@$latest_tag\n</code></pre></p>"},{"location":"api/features/","title":"Features","text":""},{"location":"api/features/#py3r.behaviour.features.features.Features","title":"py3r.behaviour.features.features.Features","text":"<pre><code>Features(tracking: Tracking)\n</code></pre> <p>generates features from a pre-processed Tracking object</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.tracking","title":"tracking  <code>instance-attribute</code>","text":"<pre><code>tracking = tracking\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = DataFrame()\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta = dict()\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle = handle\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.save","title":"save","text":"<pre><code>save(dirpath: str, *, data_format: str = 'parquet', overwrite: bool = False) -&gt; None\n</code></pre> <p>Save this Features object (and its nested Tracking) to a self-describing directory.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, os\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; # add a trivial feature so data is not empty\n&gt;&gt;&gt; s = pd.Series(range(len(t.data)), index=t.data.index)\n&gt;&gt;&gt; f.store(s, 'counter', meta={})\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     f.save(d, data_format='csv', overwrite=True)\n...     os.path.exists(os.path.join(d, 'manifest.json'))\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str) -&gt; 'Features'\n</code></pre> <p>Load a Features object previously saved with save().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, os\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; f.store(pd.Series(range(len(t.data)), index=t.data.index), 'counter', meta={})\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     f.save(d, data_format='csv', overwrite=True)\n...     f2 = Features.load(d)\n&gt;&gt;&gt; isinstance(f2, Features) and 'counter' in f2.data.columns\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_between","title":"distance_between","text":"<pre><code>distance_between(point1: str, point2: str, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns distance from point1 to point2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; res = f.distance_between('p1','p2')\n&gt;&gt;&gt; isinstance(res, pd.Series) and len(res) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_distance","title":"within_distance","text":"<pre><code>within_distance(point1: str, point2: str, distance: float, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns True for frames where point1 is within specified distance of point2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; res = f.within_distance('p1','p2', distance=15.0)\n&gt;&gt;&gt; bool((isinstance(res, pd.Series) and res.notna().any()))\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.get_point_median","title":"get_point_median","text":"<pre><code>get_point_median(point: str, dims=('x', 'y')) -&gt; tuple\n</code></pre> <p>Return the per-dimension median coordinate for a tracked point.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; med = f.get_point_median('p1', dims=('x','y'))\n&gt;&gt;&gt; isinstance(med, tuple) and len(med) == 2\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.define_boundary","title":"define_boundary","text":"<pre><code>define_boundary(points: list[str], scaling: float, scaling_y: float = None, centre: str | list[str] = None) -&gt; list[tuple[float, float]]\n</code></pre> <p>takes a list of defined points, and creates a static rescaled list of point coordinates based on median location of those points 'centre' (point about which to scale) can be a string or list of strings, in which case the median of the points will be used as the centre if 'centre' is None, the median of all the boundary points will be used as the centre 'scaling' is the factor by which to scale the boundary points, and 'scaling_y' is the factor by which to scale the y-axis if 'scaling_y' is not provided, 'scaling' will be applied to both axes</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_boundary_static","title":"within_boundary_static","text":"<pre><code>within_boundary_static(point: str, boundary: list[tuple[float, float]], boundary_name: str = None) -&gt; FeaturesResult\n</code></pre> <p>checks whether point is inside polygon defined by ordered list of boundary points boundary points must be specified as a list of numerical tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; boundary = f.define_boundary(['p1','p2','p3'], scaling=1.0)\n&gt;&gt;&gt; res = f.within_boundary_static('p1', boundary)\n&gt;&gt;&gt; bool((isinstance(res, pd.Series) and res.notna().any()))\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_boundary_dynamic","title":"within_boundary_dynamic","text":"<pre><code>within_boundary_dynamic(point: str, boundary: list[str], boundary_name: str = None) -&gt; FeaturesResult\n</code></pre> <p>checks whether point is inside polygon defined by ordered list of boundary points boundary points must be specified as a list of names of tracked points</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; res = f.within_boundary_dynamic('p1', ['p1','p2','p3'])\n&gt;&gt;&gt; bool((isinstance(res, pd.Series) and res.notna().any()))\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_boundary","title":"within_boundary","text":"<pre><code>within_boundary(point: str, boundary: list, median: bool = True, boundary_name: str = None) -&gt; FeaturesResult\n</code></pre> <p>deprecated: use within_boundary_static or within_boundary_dynamic instead checks whether point is inside polygon defined by ordered list of boundary points boundary points may either be specified as a list of numerical tuples, or as a list of names of tracked points. Optionally, pass boundary_name for a custom short name in the feature name/meta.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_to_boundary","title":"distance_to_boundary","text":"<pre><code>distance_to_boundary(point: str, boundary: list[str], median: bool = True, boundary_name: str = None) -&gt; FeaturesResult\n</code></pre> <p>Deprecated: use distance_to_boundary_static or distance_to_boundary_dynamic instead returns distance from point to boundary Optionally, pass boundary_name for a custom short name in the feature name/meta.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_to_boundary_static","title":"distance_to_boundary_static","text":"<pre><code>distance_to_boundary_static(point: str, boundary: list[tuple[float, float]], boundary_name: str = None) -&gt; FeaturesResult\n</code></pre> <p>Returns distance from point to a static boundary defined by a list of (x, y) tuples. If boundary_name is provided, it overrides the automatic id. NaN is returned if the point or any boundary vertex is NaN.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_to_boundary_dynamic","title":"distance_to_boundary_dynamic","text":"<pre><code>distance_to_boundary_dynamic(point: str, boundary: list[str], boundary_name: str | None = None) -&gt; FeaturesResult\n</code></pre> <p>Returns distance from point to a dynamic boundary defined by a list of point names. If boundary_name is provided, it overrides the automatic id. NaN is returned if the point or any boundary vertex is NaN.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.area_of_boundary","title":"area_of_boundary","text":"<pre><code>area_of_boundary(boundary: list[str], median: bool = True) -&gt; FeaturesResult\n</code></pre> <p>returns area of boundary as a FeaturesResult (constant for static, per-frame for dynamic)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; res = f.area_of_boundary(['p1','p2','p3'], median=True)\n&gt;&gt;&gt; isinstance(res, pd.Series) and res.nunique() == 1\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.acceleration","title":"acceleration","text":"<pre><code>acceleration(point: str, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns acceleration of point from previous frame to current frame, for each frame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; acc = f.acceleration('p1')\n&gt;&gt;&gt; isinstance(acc, pd.Series) and len(acc) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.azimuth","title":"azimuth","text":"<pre><code>azimuth(point1: str, point2: str) -&gt; FeaturesResult\n</code></pre> <p>returns azimuth in radians from tracked point1 to tracked point2 for each frame in the data, relative to the direction of the x-axis</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; ang = f.azimuth('p1','p2')\n&gt;&gt;&gt; isinstance(ang, pd.Series) and len(ang) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.azimuth_deviation","title":"azimuth_deviation","text":"<pre><code>azimuth_deviation(basepoint: str, pointdirection1: str, pointdirection2: str) -&gt; FeaturesResult\n</code></pre> <p>Compute the signed angular deviation (radians) between two directions from a common basepoint for each frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; dev = f.azimuth_deviation('p1','p2','p3')\n&gt;&gt;&gt; bool((isinstance(dev, pd.Series) and len(dev) == len(t.data)))\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_azimuth_deviation","title":"within_azimuth_deviation","text":"<pre><code>within_azimuth_deviation(basepoint: str, pointdirection1: str, pointdirection2: str, deviation: float) -&gt; FeaturesResult\n</code></pre> <p>Return True for frames where the angular deviation between two rays from basepoint is &lt;= deviation (radians).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; mask = f.within_azimuth_deviation('p1','p2','p3', deviation=1.0)\n&gt;&gt;&gt; bool((isinstance(mask, pd.Series) and mask.notna().any()))\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.speed","title":"speed","text":"<pre><code>speed(point: str, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns average speed of point from previous frame to current frame, for each frame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; sp = f.speed('p1')\n&gt;&gt;&gt; isinstance(sp, pd.Series) and len(sp) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.above_speed","title":"above_speed","text":"<pre><code>above_speed(point: str, speed: float, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>Return True for frames where the point's speed is &gt;= threshold.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; m = f.above_speed('p1', speed=0.0)\n&gt;&gt;&gt; isinstance(m, pd.Series) and len(m) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.all_above_speed","title":"all_above_speed","text":"<pre><code>all_above_speed(points: list, speed: float, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>Return True for frames where all listed points are moving at least at the threshold speed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; m = f.all_above_speed(['p1','p2'], speed=0.0)\n&gt;&gt;&gt; isinstance(m, pd.Series) and len(m) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.below_speed","title":"below_speed","text":"<pre><code>below_speed(point: str, speed: float, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>Return True for frames where the point's speed is &lt; threshold.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; m = f.below_speed('p1', speed=9999.0)\n&gt;&gt;&gt; isinstance(m, pd.Series) and len(m) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.all_below_speed","title":"all_below_speed","text":"<pre><code>all_below_speed(points: list, speed: float, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>Return True for frames where all listed points are moving slower than the threshold speed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; m = f.all_below_speed(['p1','p2'], speed=9999.0)\n&gt;&gt;&gt; isinstance(m, pd.Series) and len(m) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_change","title":"distance_change","text":"<pre><code>distance_change(point: str, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns unsigned distance moved by point from previous frame to current frame, for each frame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; dc = f.distance_change('p1')\n&gt;&gt;&gt; isinstance(dc, pd.Series) and len(dc) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.store","title":"store","text":"<pre><code>store(feature: Series, name: str, overwrite: bool = False, meta: dict = dict()) -&gt; None\n</code></pre> <p>stores calculated feature with name and associated freeform metadata object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; s = pd.Series(range(len(t.data)), index=t.data.index)\n&gt;&gt;&gt; f.store(s, 'counter', meta={'unit':'frames'})\n&gt;&gt;&gt; 'counter' in f.data.columns and f.meta['counter']['unit'] == 'frames'\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.classify","title":"classify","text":"<pre><code>classify(classifier: BaseClassifier, **kwargs)\n</code></pre> <p>classify behaviour using a classifier with inputs from this Features object returns a FeaturesResult object with the classification result this means that the output of the classifier should be a pd.Series with the same index as this Features object</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.smooth","title":"smooth","text":"<pre><code>smooth(name: str, method: str, window: int, center: bool = True, inplace: bool = False) -&gt; pd.Series\n</code></pre> <p>smooths specified feature with specified method over rolling window. if inplace=True then feature will be directly edited and metadata updated method:     'median' : median of value in window, requires numerical series values     'mean' : mean of value in window, requires numerical series values     'mode' : mode value in window, works with numerical or non-numerical types     'block' : removes labels that occur in blocks of less than length window               and replaces them with value from previous block unless there is               no previous block, in which case replaced from next block after smoothing               note: all nan values will be filled using this method (dangerous!)</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.embedding_df","title":"embedding_df","text":"<pre><code>embedding_df(embedding: dict[str, list[int]])\n</code></pre> <p>generate a time series embedding dataframe with specified time shifts for each column, where embedding is a dict mapping column names to lists of shifts positive shift: value from the future (t+n) negative shift: value from the past (t-n)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; # prepare a simple feature to embed\n&gt;&gt;&gt; s = pd.Series(range(len(t.data)), index=t.data.index)\n&gt;&gt;&gt; f.store(s, 'counter', meta={})\n&gt;&gt;&gt; emb = f.embedding_df({'counter':[0,1,-1]})\n&gt;&gt;&gt; list(emb.columns)\n['counter_t0', 'counter_t+1', 'counter_t-1']\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.assign_clusters_by_centroids","title":"assign_clusters_by_centroids","text":"<pre><code>assign_clusters_by_centroids(embedding: dict[str, list[int]], centroids_df: DataFrame) -&gt; pd.Series\n</code></pre> <p>new_embed_df: (n_samples, n_features)  DataFrame of your new time-shifted embedding centroids_df: (n_clusters, n_features) DataFrame of cluster centers Returns a Series of cluster IDs (0..n_clusters-1) indexed like new_embed_df.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; # add a simple feature to embed\n&gt;&gt;&gt; f.store(pd.Series(range(len(t.data)), index=t.data.index), 'counter', meta={})\n&gt;&gt;&gt; emb = {'counter':[0, 1]}\n&gt;&gt;&gt; df = f.embedding_df(emb)\n&gt;&gt;&gt; # make 2 simple centroids matching columns\n&gt;&gt;&gt; cents = pd.DataFrame([[0, 0], [1, 1]], columns=df.columns)\n&gt;&gt;&gt; labels = f.assign_clusters_by_centroids(emb, cents)\n&gt;&gt;&gt; isinstance(labels, pd.Series) and len(labels) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.train_knn_regressor","title":"train_knn_regressor","text":"<pre><code>train_knn_regressor(*, source_embedding: dict[str, list[int]], target_embedding: dict[str, list[int]], n_neighbors: int = 5, normalize_source: bool = False, **kwargs)\n</code></pre> <p>Developer mode: not available in public release yet.</p> <p>Train a KNN regressor to predict a target embedding from a feature embedding on this Features object. If normalize_source is True, normalize the source embedding before training and return the rescale factors. Returns the trained model, input columns, target columns, and (optionally) the rescale factors.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.predict_knn","title":"predict_knn","text":"<pre><code>predict_knn(model: KNeighborsRegressor, source_embedding: dict[str, list[int]], target_embedding: dict[str, list[int]], rescale_factors: dict = None) -&gt; pd.DataFrame\n</code></pre> <p>Developer mode: not available in public release yet.</p> <p>Predict using a trained KNN regressor on this Features object. If rescale_factors is provided, normalize the source embedding before prediction. The prediction will match the shape and columns of self.embedding_df(target_embedding).</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.rms_error_between_embeddings","title":"rms_error_between_embeddings  <code>staticmethod</code>","text":"<pre><code>rms_error_between_embeddings(ground_truth: DataFrame, prediction: DataFrame, rescale: dict | str = None) -&gt; pd.Series\n</code></pre> <p>Developer mode: not available in public release yet.</p> <p>Compute the root mean squared error (RMS) for each row between two embedding DataFrames. If rescale is a dict, normalize both DataFrames using this dict before computing the error. If rescale == 'auto', compute normalization factors from ground_truth and apply to both DataFrames. Returns a Series indexed like the input DataFrames, with NaN for rows where either input has NaNs.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.define_elliptical_boundary_from_params","title":"define_elliptical_boundary_from_params","text":"<pre><code>define_elliptical_boundary_from_params(centre: str | list[str], major_axis_length: float, minor_axis_length: float, angle_in_radians: float = 0.0, n_points: int = 100) -&gt; list[tuple[float, float]]\n</code></pre> <p>Generate a polygonal approximation of an ellipse as a list of (x, y) tuples, around <code>centre</code> using explicit parameters. <code>centre</code> can be a single point name or a list of point names. if <code>centre</code> is a list, the boundary will be centred on the mean of the median coordinates of the points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; poly = f.define_elliptical_boundary_from_params('p1', major_axis_length=10, minor_axis_length=6, angle_in_radians=0.0, n_points=32)\n&gt;&gt;&gt; isinstance(poly, list) and len(poly) == 32\nTrue\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.define_elliptical_boundary_from_points","title":"define_elliptical_boundary_from_points","text":"<pre><code>define_elliptical_boundary_from_points(points: list[str], n_points: int = 100, scaling: float = 1.0, smallness_weight: float = 0.1) -&gt; list[tuple[float, float]]\n</code></pre> <p>Fit an ellipse to the median coordinates of the given tracked points (at least 4) and return a polygonal approximation. After fitting, the ellipse is scaled by <code>scaling</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; # Use exactly 4 points to avoid requiring skimage in tests\n&gt;&gt;&gt; poly = f.define_elliptical_boundary_from_points(['p1','p2','p3','p2'], n_points=20, scaling=1.0)\n&gt;&gt;&gt; isinstance(poly, list) and len(poly) == 20\nTrue\n</code></pre>"},{"location":"api/features_collection/","title":"FeaturesCollection","text":""},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection","title":"py3r.behaviour.features.features_collection.FeaturesCollection","text":"<pre><code>FeaturesCollection(features_dict: dict[str, Features])\n</code></pre> <p>               Bases: <code>BaseCollection</code>, <code>FeaturesCollectionBatchMixin</code></p> <p>Collection of Features objects, keyed by name. note: type-hints refer to Features, but factory methods allow for other classes these are intended ONLY for subclasses of Features, and this is enforced</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; list(sorted(fc.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.features_dict","title":"features_dict  <code>property</code>","text":"<pre><code>features_dict\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.is_grouped","title":"is_grouped  <code>property</code>","text":"<pre><code>is_grouped\n</code></pre> <p>True if this collection is a grouped view.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; coll.is_grouped\nFalse\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.groupby_tags","title":"groupby_tags  <code>property</code>","text":"<pre><code>groupby_tags\n</code></pre> <p>The tag names used to form this grouped view (or None if flat).</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.group_keys","title":"group_keys  <code>property</code>","text":"<pre><code>group_keys\n</code></pre> <p>Keys for the groups in a grouped view. Empty list if not grouped.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; sorted(g.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.from_tracking_collection","title":"from_tracking_collection  <code>classmethod</code>","text":"<pre><code>from_tracking_collection(tracking_collection: TrackingCollection, feature_cls=Features)\n</code></pre> <p>Create a FeaturesCollection from a TrackingCollection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; isinstance(fc['A'], Features) and isinstance(fc['B'], Features)\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.within_boundary_static","title":"within_boundary_static","text":"<pre><code>within_boundary_static(point: str, boundary, boundary_name: str = None)\n</code></pre> <p>Collection-aware wrapper that supports:   - a single static <code>boundary</code> (list[(x,y)]) applied to all items, or   - a per-handle mapping of boundaries produced by batch <code>define_boundary</code>:     - flat: {handle: list[(x,y)]}     - grouped: {group_key: {handle: list[(x,y)]}}     - BatchResult in either of the above shapes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; boundaries = fc.define_boundary(['p1','p2','p3'], scaling=1.0)\n&gt;&gt;&gt; res = fc.within_boundary_static('p1', boundaries)\n&gt;&gt;&gt; isinstance(res, dict)\nTrue\n&gt;&gt;&gt; any(isinstance(v, pd.Series) for v in res.values())\nTrue\n\n&gt;&gt;&gt; # Grouped case: add tags on Tracking, group, then build grouped FeaturesCollection\n&gt;&gt;&gt; # (boundaries BatchResult structure matches grouped layout)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n...     tc['A'].add_tag('group', 'G1'); tc['B'].add_tag('group', 'G2')\n...     gtc = tc.groupby('group')\n...     gfc = FeaturesCollection.from_tracking_collection(gtc)\n...     g_boundaries = gfc.define_boundary(['p1','p2','p3'], scaling=1.0)\n...     g_res = gfc.within_boundary_static('p1', g_boundaries)\n&gt;&gt;&gt; isinstance(g_res, dict)\nTrue\n&gt;&gt;&gt; any(any(isinstance(s, pd.Series) for s in sub.values()) for sub in g_res.values())\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.distance_to_boundary_static","title":"distance_to_boundary_static","text":"<pre><code>distance_to_boundary_static(point: str, boundary, boundary_name: str = None)\n</code></pre> <p>Collection-aware wrapper that supports:   - a single static <code>boundary</code> (list[(x,y)]) applied to all items, or   - a per-handle mapping of boundaries produced by batch <code>define_boundary</code>:     - flat: {handle: list[(x,y)]}     - grouped: {group_key: {handle: list[(x,y)]}}     - BatchResult in either of the above shapes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; boundaries = fc.define_boundary(['p1','p2','p3'], scaling=1.0)\n&gt;&gt;&gt; res = fc.distance_to_boundary_static('p1', boundaries)\n&gt;&gt;&gt; isinstance(res, dict)\nTrue\n&gt;&gt;&gt; any(isinstance(v, pd.Series) for v in res.values())\nTrue\n\n&gt;&gt;&gt; # Grouped case\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n...     tc['A'].add_tag('group', 'G1'); tc['B'].add_tag('group', 'G2')\n...     gtc = tc.groupby('group')\n...     gfc = FeaturesCollection.from_tracking_collection(gtc)\n...     g_boundaries = gfc.define_boundary(['p1','p2','p3'], scaling=1.0)\n...     g_res = gfc.distance_to_boundary_static('p1', g_boundaries)\n&gt;&gt;&gt; isinstance(g_res, dict)\nTrue\n&gt;&gt;&gt; any(any(isinstance(s, pd.Series) for s in sub.values()) for sub in g_res.values())\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(features_list: list[Features])\n</code></pre> <p>Create a FeaturesCollection from a list of Features objects, keyed by handle</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t1 = Tracking.from_dlc(str(p), handle='A', fps=30)\n...     t2 = Tracking.from_dlc(str(p), handle='B', fps=30)\n&gt;&gt;&gt; f1, f2 = Features(t1), Features(t2)\n&gt;&gt;&gt; fc = FeaturesCollection.from_list([f1, f2])\n&gt;&gt;&gt; list(sorted(fc.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.cluster_embedding","title":"cluster_embedding","text":"<pre><code>cluster_embedding(embedding_dict: dict[str, list[int]], n_clusters: int, random_state: int = 0, *, auto_normalize: bool = False, rescale_factors: dict | None = None, lowmem: bool = False, decimation_factor: int = 10, custom_scaling: dict[str, dict] | None = None)\n</code></pre> <p>Perform k-means clustering using the specified embedding.</p> <p>Unified behaviour for flat and grouped collections. Returns a BatchResult mapping:   - grouped: {group_key: {feature_handle: FeaturesResult}}   - flat:    {feature_handle: FeaturesResult} along with (centroids, normalization_factors or None).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; # Create a trivial feature 'counter' in each Features to embed\n&gt;&gt;&gt; for f in fc.values():\n...     s = pd.Series(range(len(f.tracking.data)), index=f.tracking.data.index)\n...     f.store(s, 'counter')\n&gt;&gt;&gt; batch, centroids, norm = fc.cluster_embedding({'counter':[0]}, n_clusters=2, lowmem=True)\n&gt;&gt;&gt; isinstance(centroids, pd.DataFrame)\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.cross_predict_rms","title":"cross_predict_rms","text":"<pre><code>cross_predict_rms(source_embedding: dict[str, list[int]], target_embedding: dict[str, list[int]], normalize_source: bool = False, normalize_pred: dict | str = None, set1: list | None = None, set2: list | None = None, predictor_cls=None, predictor_kwargs=None)\n</code></pre> <p>Dev mode only: not available in public release yet.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.plot_cross_predict_vs_within","title":"plot_cross_predict_vs_within  <code>staticmethod</code>","text":"<pre><code>plot_cross_predict_vs_within(results, from_group, to_group, show=True)\n</code></pre> <p>Dev mode only: not available in public release yet.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.plot_cross_predict_results","title":"plot_cross_predict_results  <code>staticmethod</code>","text":"<pre><code>plot_cross_predict_results(results, within_keys=None, between_keys=None, plot_type='bar', figsize=(10, 6), show=True)\n</code></pre> <p>Dev mode only: not available in public release yet.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.dumbbell_plot_cross_predict","title":"dumbbell_plot_cross_predict  <code>staticmethod</code>","text":"<pre><code>dumbbell_plot_cross_predict(results, within_key, between_key, figsize=(3, 3), show=True)\n</code></pre> <p>Dev mode only: not available in public release yet.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.train_knn_regressor","title":"train_knn_regressor","text":"<pre><code>train_knn_regressor(*, source_embedding: dict[str, list[int]], target_embedding: dict[str, list[int]], predictor_cls=None, predictor_kwargs=None, normalize_source: bool = False, **kwargs)\n</code></pre> <p>Dev mode only: not available in public release yet.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.predict_knn","title":"predict_knn","text":"<pre><code>predict_knn(model, source_embedding: dict[str, list[int]], target_embedding: dict[str, list[int]], rescale_factors: dict = None) -&gt; pd.DataFrame\n</code></pre> <p>Dev mode only: not available in public release yet.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.plot","title":"plot","text":"<pre><code>plot(arg=None, figsize=(8, 2), show: bool = True, title: str = None)\n</code></pre> <p>Plot features for all collections in the MultipleFeaturesCollection. - If arg is a BatchResult or dict: treat as batch result and plot for each collection. - Otherwise: treat as column name(s) or None and plot for each collection. - If title is provided, it will be used as the overall title for the figure.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.store","title":"store","text":"<pre><code>store(results_dict, name: str = None, meta: dict = None, overwrite: bool = False)\n</code></pre> <p>Store FeaturesResult objects returned by batch methods.</p> <ul> <li>Flat collection: results_dict is {handle: FeaturesResult}</li> <li>Grouped collection: results_dict is {group_key: {handle: FeaturesResult}}</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; # Build a simple FeaturesResult dict from distance_between\n&gt;&gt;&gt; rd = {h: feat.distance_between('p1','p2') for h, feat in fc.items()}\n&gt;&gt;&gt; fc.store(rd, name='d12')\n&gt;&gt;&gt; all('d12' in feat.data.columns for feat in fc.values())\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.save","title":"save","text":"<pre><code>save(dirpath: str, *, overwrite: bool = False, data_format: str = 'parquet') -&gt; None\n</code></pre> <p>Save this collection to a directory. Preserves grouping and delegates to leaf objects' save(dirpath, data_format, overwrite=True).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, os\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     out = d / 'coll'\n...     coll.save(str(out), overwrite=True, data_format='csv')\n...     # collection-level manifest at top-level\n...     assert os.path.exists(os.path.join(str(out), 'manifest.json'))\n...     # element-level manifests under elements/&lt;handle&gt;/\n...     assert os.path.exists(os.path.join(str(out), 'elements', 'A', 'manifest.json'))\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.distance_between","title":"distance_between","text":"<pre><code>distance_between(point1: str, point2: str, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.distance_between across the collection.</p> <p>See <code>Features.distance_between</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.within_distance","title":"within_distance","text":"<pre><code>within_distance(point1: str, point2: str, distance: float, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.within_distance across the collection.</p> <p>See <code>Features.within_distance</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.get_point_median","title":"get_point_median","text":"<pre><code>get_point_median(point: str, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.get_point_median across the collection.</p> <p>Return the per-dimension median coordinate for a tracked point.</p> <p>See <code>Features.get_point_median</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.define_boundary","title":"define_boundary","text":"<pre><code>define_boundary(points: list[str], scaling: float, scaling_y: float = None, centre: str | list[str] = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.define_boundary across the collection.</p> <p>takes a list of defined points, and creates a static rescaled list of point coordinates based on median location of those points 'centre' (point about which to scale) can be a string or list of strings, in which case the median of the points will be used as the centre if 'centre' is None, the median of all the boundary points will be used as the centre 'scaling' is the factor by which to scale the boundary points, and 'scaling_y' is the factor by which to scale the y-axis if 'scaling_y' is not provided, 'scaling' will be applied to both axes</p> <p>See <code>Features.define_boundary</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.within_boundary_dynamic","title":"within_boundary_dynamic","text":"<pre><code>within_boundary_dynamic(point: str, boundary: list[str], boundary_name: str = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.within_boundary_dynamic across the collection.</p> <p>checks whether point is inside polygon defined by ordered list of boundary points boundary points must be specified as a list of names of tracked points</p> <p>See <code>Features.within_boundary_dynamic</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.within_boundary","title":"within_boundary","text":"<pre><code>within_boundary(point: str, boundary: list, median: bool = True, boundary_name: str = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.within_boundary across the collection.</p> <p>deprecated: use within_boundary_static or within_boundary_dynamic instead checks whether point is inside polygon defined by ordered list of boundary points boundary points may either be specified as a list of numerical tuples, or as a list of names of tracked points. Optionally, pass boundary_name for a custom short name in the feature name/meta.</p> <p>See <code>Features.within_boundary</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.distance_to_boundary","title":"distance_to_boundary","text":"<pre><code>distance_to_boundary(point: str, boundary: list[str], median: bool = True, boundary_name: str = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.distance_to_boundary across the collection.</p> <p>Deprecated: use distance_to_boundary_static or distance_to_boundary_dynamic instead</p> <p>See <code>Features.distance_to_boundary</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.distance_to_boundary_dynamic","title":"distance_to_boundary_dynamic","text":"<pre><code>distance_to_boundary_dynamic(point: str, boundary: list[str], boundary_name: str | None = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.distance_to_boundary_dynamic across the collection.</p> <p>See <code>Features.distance_to_boundary_dynamic</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.area_of_boundary","title":"area_of_boundary","text":"<pre><code>area_of_boundary(boundary: list[str], median: bool = True) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.area_of_boundary across the collection.</p> <p>See <code>Features.area_of_boundary</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.acceleration","title":"acceleration","text":"<pre><code>acceleration(point: str, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.acceleration across the collection.</p> <p>See <code>Features.acceleration</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.azimuth","title":"azimuth","text":"<pre><code>azimuth(point1: str, point2: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.azimuth across the collection.</p> <p>See <code>Features.azimuth</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.azimuth_deviation","title":"azimuth_deviation","text":"<pre><code>azimuth_deviation(basepoint: str, pointdirection1: str, pointdirection2: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.azimuth_deviation across the collection.</p> <p>Compute the signed angular deviation (radians) between two directions from a common basepoint for each frame.</p> <p>See <code>Features.azimuth_deviation</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.within_azimuth_deviation","title":"within_azimuth_deviation","text":"<pre><code>within_azimuth_deviation(basepoint: str, pointdirection1: str, pointdirection2: str, deviation: float) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.within_azimuth_deviation across the collection.</p> <p>Return True for frames where the angular deviation between two rays from basepoint is &lt;= deviation (radians).</p> <p>See <code>Features.within_azimuth_deviation</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.speed","title":"speed","text":"<pre><code>speed(point: str, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.speed across the collection.</p> <p>See <code>Features.speed</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.above_speed","title":"above_speed","text":"<pre><code>above_speed(point: str, speed: float, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.above_speed across the collection.</p> <p>Return True for frames where the point's speed is &gt;= threshold.</p> <p>See <code>Features.above_speed</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.all_above_speed","title":"all_above_speed","text":"<pre><code>all_above_speed(points: list, speed: float, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.all_above_speed across the collection.</p> <p>Return True for frames where all listed points are moving at least at the threshold speed.</p> <p>See <code>Features.all_above_speed</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.below_speed","title":"below_speed","text":"<pre><code>below_speed(point: str, speed: float, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.below_speed across the collection.</p> <p>Return True for frames where the point's speed is &lt; threshold.</p> <p>See <code>Features.below_speed</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.all_below_speed","title":"all_below_speed","text":"<pre><code>all_below_speed(points: list, speed: float, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.all_below_speed across the collection.</p> <p>Return True for frames where all listed points are moving slower than the threshold speed.</p> <p>See <code>Features.all_below_speed</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.distance_change","title":"distance_change","text":"<pre><code>distance_change(point: str, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.distance_change across the collection.</p> <p>See <code>Features.distance_change</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.classify","title":"classify","text":"<pre><code>classify(classifier: BaseClassifier, **kwargs) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.classify across the collection.</p> <p>classify behaviour using a classifier with inputs from this Features object</p> <p>See <code>Features.classify</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.smooth","title":"smooth","text":"<pre><code>smooth(name: str, method: str, window: int, center: bool = True, inplace: bool = False) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.smooth across the collection.</p> <p>smooths specified feature with specified method over rolling window. if inplace=True then feature will be directly edited and metadata updated method:     'median' : median of value in window, requires numerical series values     'mean' : mean of value in window, requires numerical series values     'mode' : mode value in window, works with numerical or non-numerical types     'block' : removes labels that occur in blocks of less than length window               and replaces them with value from previous block unless there is               no previous block, in which case replaced from next block after smoothing               note: all nan values will be filled using this method (dangerous!)</p> <p>See <code>Features.smooth</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.embedding_df","title":"embedding_df","text":"<pre><code>embedding_df(embedding: dict[str, list[int]]) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.embedding_df across the collection.</p> <p>generate a time series embedding dataframe with specified time shifts for each column, where embedding is a dict mapping column names to lists of shifts positive shift: value from the future (t+n) negative shift: value from the past (t-n)</p> <p>See <code>Features.embedding_df</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.assign_clusters_by_centroids","title":"assign_clusters_by_centroids","text":"<pre><code>assign_clusters_by_centroids(embedding: dict[str, list[int]], centroids_df: DataFrame) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.assign_clusters_by_centroids across the collection.</p> <p>new_embed_df: (n_samples, n_features)  DataFrame of your new time-shifted embedding centroids_df: (n_clusters, n_features) DataFrame of cluster centers</p> <p>See <code>Features.assign_clusters_by_centroids</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.define_elliptical_boundary_from_params","title":"define_elliptical_boundary_from_params","text":"<pre><code>define_elliptical_boundary_from_params(centre: str | list[str], major_axis_length: float, minor_axis_length: float, angle_in_radians: float = 0.0, n_points: int = 100) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.define_elliptical_boundary_from_params across the collection.</p> <p>Generate a polygonal approximation of an ellipse as a list of (x, y) tuples, around <code>centre</code> using explicit parameters. <code>centre</code> can be a single point name or a list of point names. if <code>centre</code> is a list, the boundary will be centred on the mean of the median coordinates of the points.</p> <p>See <code>Features.define_elliptical_boundary_from_params</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.define_elliptical_boundary_from_points","title":"define_elliptical_boundary_from_points","text":"<pre><code>define_elliptical_boundary_from_points(points: list[str], n_points: int = 100, scaling: float = 1.0, smallness_weight: float = 0.1) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Features.define_elliptical_boundary_from_points across the collection.</p> <p>Fit an ellipse to the median coordinates of the given tracked points (at least 4) and return a polygonal approximation. After fitting, the ellipse is scaled by <code>scaling</code>.</p> <p>See <code>Features.define_elliptical_boundary_from_points</code> for examples.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Values iterator (elements or sub-collections).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; len(list(coll.values())) == 2\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Items iterator (handle, element).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sorted([h for h, _ in coll.items()])\n['A', 'B']\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Keys iterator (handles or group keys).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; list(sorted(coll.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.groupby","title":"groupby","text":"<pre><code>groupby(tags)\n</code></pre> <p>Group the collection by one or more existing tag names. Returns a grouped view (this same collection type) whose values are sub-collections keyed by a tuple of tag values in the order provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; g.is_grouped\nTrue\n&gt;&gt;&gt; sorted(g.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.flatten","title":"flatten","text":"<pre><code>flatten()\n</code></pre> <p>Flatten a MultipleCollection to a flat Collection. If already flat, return self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G1')\n...     g = coll.groupby('group')\n&gt;&gt;&gt; flat = g.flatten()\n&gt;&gt;&gt; flat.is_grouped\nFalse\n&gt;&gt;&gt; sorted(flat.keys())\n['A', 'B']\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.get_group","title":"get_group","text":"<pre><code>get_group(key)\n</code></pre> <p>Get a sub-collection by group key from a grouped view.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; sub = g.get_group(('G1',))\n&gt;&gt;&gt; list(sub.keys())\n['A']\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.regroup","title":"regroup","text":"<pre><code>regroup()\n</code></pre> <p>Recompute the same grouping using the current tags and the original grouping tag order. If not grouped, returns self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G1')\n...     g = coll.groupby('group')\n...     coll['B'].add_tag('group','G2', overwrite=True)  # change tag\n&gt;&gt;&gt; g2 = g.regroup()\n&gt;&gt;&gt; sorted(g2.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.map_leaves","title":"map_leaves","text":"<pre><code>map_leaves(fn)\n</code></pre> <p>Apply a function to every leaf element and return a new collection of the same type. Preserves grouping shape and groupby metadata when grouped.</p> <p>fn: callable(Element) -&gt; ElementLike</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sub = coll.map_leaves(lambda t: t.loc[0:1])\n&gt;&gt;&gt; all(len(t.data) == 2 for t in sub.values())\nTrue\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str)\n</code></pre> <p>Load a collection previously saved with save(). Uses the class's _element_type.load to reconstruct leaves.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     out = d / 'coll'\n...     coll.save(str(out), overwrite=True, data_format='csv')\n...     coll2 = TrackingCollection.load(str(out))\n&gt;&gt;&gt; list(sorted(coll2.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/summary/","title":"Summary","text":""},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary","title":"py3r.behaviour.summary.summary.Summary","text":"<pre><code>Summary(trackingfeatures: Features)\n</code></pre> <p>stores and computes summary statistics from features objects</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.features","title":"features  <code>instance-attribute</code>","text":"<pre><code>features = trackingfeatures\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = dict()\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta = dict()\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle = handle\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.save","title":"save","text":"<pre><code>save(dirpath: str, *, data_format: str = 'parquet', overwrite: bool = False) -&gt; None\n</code></pre> <p>Save this Summary (including nested Features/Tracking) to a directory.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, os, pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; # add a boolean feature for summary methods to use\n&gt;&gt;&gt; mask = pd.Series([True, False] * (len(t.data)//2 + 1))[:len(t.data)]\n&gt;&gt;&gt; mask.index = t.data.index\n&gt;&gt;&gt; f.store(mask, 'mask', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     s.save(d, data_format='csv', overwrite=True)\n...     os.path.exists(os.path.join(d, 'manifest.json'))\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str) -&gt; 'Summary'\n</code></pre> <p>Load a Summary previously saved with save().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; f.store(pd.Series(range(len(t.data)), index=t.data.index), 'counter', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     s.save(d, data_format='csv', overwrite=True)\n...     s2 = Summary.load(d)\n&gt;&gt;&gt; isinstance(s2, Summary) and 'counter' in s2.features.data.columns\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.count_onset","title":"count_onset","text":"<pre><code>count_onset(column: str) -&gt; SummaryResult\n</code></pre> <p>counts number of times boolean series in the given column changes from False to True, ignoring nan values if first non nan value in series is true, this counts as an onset</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; mask = pd.Series([False, True, False, True, False][:len(t.data)], index=t.data.index)\n&gt;&gt;&gt; f.store(mask, 'mask', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.count_onset('mask')\n&gt;&gt;&gt; bool(res.value == 2)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.time_true","title":"time_true","text":"<pre><code>time_true(column: str) -&gt; SummaryResult\n</code></pre> <p>returns time in seconds that condition in the given column is true</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; mask = pd.Series([True] * len(t.data), index=t.data.index)\n&gt;&gt;&gt; f.store(mask, 'mask', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.time_true('mask')\n&gt;&gt;&gt; bool(res.value &gt; 0)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.time_false","title":"time_false","text":"<pre><code>time_false(column: str) -&gt; SummaryResult\n</code></pre> <p>returns time in seconds that condition in the given column is false</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; mask = pd.Series([False] * len(t.data), index=t.data.index)\n&gt;&gt;&gt; f.store(mask, 'mask', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.time_false('mask')\n&gt;&gt;&gt; bool(res.value &gt; 0)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.total_distance","title":"total_distance","text":"<pre><code>total_distance(point: str, startframe: int | None = None, endframe: int | None = None) -&gt; SummaryResult\n</code></pre> <p>returns total distance traveled by a tracked point between optional start and end frames</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.total_distance('p1', 0, 4)\n&gt;&gt;&gt; isinstance(res.value, (int, float))\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.sum_column","title":"sum_column","text":"<pre><code>sum_column(column: str) -&gt; SummaryResult\n</code></pre> <p>Sum all non-NaN values in a <code>features.data</code> column and return as a SummaryResult.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; s = pd.Series([1, 2, 3, 4, 5][:len(t.data)], index=t.data.index)\n&gt;&gt;&gt; f.store(s, 'x', meta={})\n&gt;&gt;&gt; summ = Summary(f)\n&gt;&gt;&gt; res = summ.sum_column('x')\n&gt;&gt;&gt; bool(res.value == 15)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.store","title":"store","text":"<pre><code>store(summarystat: Any, name: str, overwrite: bool = False, meta: Any = None) -&gt; None\n</code></pre> <p>stores a summary statistic and optional metadata, with optional overwrite protection</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; s.store(123, 'num_events', meta={'unit':'count'})\n&gt;&gt;&gt; s.data['num_events'] == 123 and s.meta['num_events']['unit'] == 'count'\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.make_bin","title":"make_bin","text":"<pre><code>make_bin(startframe: int, endframe: int) -&gt; 'Summary'\n</code></pre> <p>creates a copy of the Summary object with the dataframes restricted from startframe to endframe, inclusive</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; b = s.make_bin(0, 2)\n&gt;&gt;&gt; isinstance(b, Summary)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.make_bins","title":"make_bins","text":"<pre><code>make_bins(numbins: int) -&gt; List[Summary]\n</code></pre> <p>creates a list of Summary objects, with frames restricted into numbins even intervals. start/endpoints are duplicated between intervals to ensure no loss in e.g. distance calculations</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; bins = s.make_bins(3)\n&gt;&gt;&gt; len(bins) == 3 and all(isinstance(b, Summary) for b in bins)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.transition_matrix","title":"transition_matrix","text":"<pre><code>transition_matrix(column: str, all_states=None) -&gt; SummaryResult\n</code></pre> <p>Returns a transition matrix for a given column in self.features.data, with rows and columns as the unique values of the column or as specified by all_states.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; states = pd.Series(['A','A','B','B','A'][:len(t.data)], index=t.data.index)\n&gt;&gt;&gt; f.store(states, 'state', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.transition_matrix('state')\n&gt;&gt;&gt; isinstance(res.value, pd.DataFrame)\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.count_state_onsets","title":"count_state_onsets","text":"<pre><code>count_state_onsets(column: str) -&gt; SummaryResult\n</code></pre> <p>counts the number of times a state is entered in a given column</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; states = pd.Series(['A','A','B','B','A'][:len(t.data)], index=t.data.index)\n&gt;&gt;&gt; f.store(states, 'state', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.count_state_onsets('state')\n&gt;&gt;&gt; hasattr(res, 'value')\nTrue\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.time_in_state","title":"time_in_state","text":"<pre><code>time_in_state(column: str) -&gt; SummaryResult\n</code></pre> <p>returns the time spent in each state in a given column</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; f = Features(t)\n&gt;&gt;&gt; states = pd.Series(['A','A','B','B','A'][:len(t.data)], index=t.data.index)\n&gt;&gt;&gt; f.store(states, 'state', meta={})\n&gt;&gt;&gt; s = Summary(f)\n&gt;&gt;&gt; res = s.time_in_state('state')\n&gt;&gt;&gt; hasattr(res, 'value')\nTrue\n</code></pre>"},{"location":"api/summary_collection/","title":"SummaryCollection","text":""},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection","title":"py3r.behaviour.summary.summary_collection.SummaryCollection","text":"<pre><code>SummaryCollection(summary_dict: dict[str, Summary])\n</code></pre> <p>               Bases: <code>BaseCollection</code>, <code>SummaryCollectionBatchMixin</code></p> <p>collection of Summary objects (e.g. for grouping individuals) note: type-hints refer to Summary, but factory methods allow for other classes these are intended ONLY for subclasses of Summary, and this is enforced</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; from py3r.behaviour.features.features_collection import FeaturesCollection\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; # add a simple boolean feature to each Features for summaries to consume\n&gt;&gt;&gt; for f in fc.values():\n...     s = pd.Series([True, False] * (len(f.tracking.data)//2 + 1))[:len(f.tracking.data)]\n...     s.index = f.tracking.data.index\n...     f.store(s, 'flag', meta={})\n&gt;&gt;&gt; sc = SummaryCollection.from_features_collection(fc)\n&gt;&gt;&gt; list(sorted(sc.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.summary_dict","title":"summary_dict  <code>property</code>","text":"<pre><code>summary_dict\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.is_grouped","title":"is_grouped  <code>property</code>","text":"<pre><code>is_grouped\n</code></pre> <p>True if this collection is a grouped view.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; coll.is_grouped\nFalse\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.groupby_tags","title":"groupby_tags  <code>property</code>","text":"<pre><code>groupby_tags\n</code></pre> <p>The tag names used to form this grouped view (or None if flat).</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.group_keys","title":"group_keys  <code>property</code>","text":"<pre><code>group_keys\n</code></pre> <p>Keys for the groups in a grouped view. Empty list if not grouped.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; sorted(g.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.from_features_collection","title":"from_features_collection  <code>classmethod</code>","text":"<pre><code>from_features_collection(features_collection: FeaturesCollection, summary_cls=Summary)\n</code></pre> <p>creates a SummaryCollection from a FeaturesCollection (flat or grouped)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; from py3r.behaviour.features.features_collection import FeaturesCollection\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; # add numeric scalar per Features via a quick summary to test to_df later\n&gt;&gt;&gt; for f in fc.values():\n...     import numpy as np, pandas as pd\n...     f.store(pd.Series(range(len(f.tracking.data)), index=f.tracking.data.index), 'counter', meta={})\n&gt;&gt;&gt; sc = SummaryCollection.from_features_collection(fc)\n&gt;&gt;&gt; isinstance(sc['A'], Summary) and isinstance(sc['B'], Summary)\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(summary_list: list[Summary])\n</code></pre> <p>creates a SummaryCollection from a list of Summary objects, keyed by handle</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t1 = Tracking.from_dlc(str(p), handle='A', fps=30)\n...     t2 = Tracking.from_dlc(str(p), handle='B', fps=30)\n&gt;&gt;&gt; f1, f2 = Features(t1), Features(t2)\n&gt;&gt;&gt; # store simple scalar summaries\n&gt;&gt;&gt; s1, s2 = Summary(f1), Summary(f2)\n&gt;&gt;&gt; s1.store(1, 'count'); s2.store(2, 'count')\n&gt;&gt;&gt; sc = SummaryCollection.from_list([s1, s2])\n&gt;&gt;&gt; list(sorted(sc.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.to_df","title":"to_df","text":"<pre><code>to_df(include_tags: bool = False, tag_prefix: str = 'tag_')\n</code></pre> <p>Collate scalar values (numeric, string, bool) from each Summary.data into a pandas DataFrame.</p> <ul> <li>Index: handles of the Summary objects</li> <li>Columns: keys from each Summary.data (simple scalar values)</li> <li>If include_tags is True, include tag columns with the given prefix</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t1 = Tracking.from_dlc(str(p), handle='A', fps=30)\n...     t2 = Tracking.from_dlc(str(p), handle='B', fps=30)\n&gt;&gt;&gt; s1, s2 = Summary(Features(t1)), Summary(Features(t2))\n&gt;&gt;&gt; s1.store(1.0, 'score'); s2.store(2.0, 'score')\n&gt;&gt;&gt; s1.features.tracking.add_tag('group', 'G1'); s2.features.tracking.add_tag('group', 'G2')\n&gt;&gt;&gt; sc = SummaryCollection.from_list([s1, s2])\n&gt;&gt;&gt; df = sc.to_df(include_tags=True)\n&gt;&gt;&gt; set(df.columns) &gt;= {'score', 'tag_group'}\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.make_bin","title":"make_bin","text":"<pre><code>make_bin(startframe, endframe)\n</code></pre> <p>returns a new SummaryCollection with binned summaries</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='A', fps=30)\n&gt;&gt;&gt; s = Summary(Features(t))\n&gt;&gt;&gt; sc = SummaryCollection.from_list([s])\n&gt;&gt;&gt; b = sc.make_bin(0, 2)\n&gt;&gt;&gt; isinstance(b, SummaryCollection)\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.make_bins","title":"make_bins","text":"<pre><code>make_bins(numbins)\n</code></pre> <p>returns a list of SummaryCollection, one per bin</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.features.features import Features\n&gt;&gt;&gt; from py3r.behaviour.summary.summary import Summary\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='A', fps=30)\n&gt;&gt;&gt; sc = SummaryCollection.from_list([Summary(Features(t))])\n&gt;&gt;&gt; bins = sc.make_bins(3)\n&gt;&gt;&gt; len(bins) == 3 and all(isinstance(b, SummaryCollection) for b in bins)\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.store","title":"store","text":"<pre><code>store(results_dict: dict[str, SummaryResult], name: str = None, meta: dict = None, overwrite: bool = False)\n</code></pre> <p>Store all SummaryResult objects in a one-layer dict (as returned by batch methods).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd, tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; from py3r.behaviour.features.features_collection import FeaturesCollection\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; # add a boolean column for summaries\n&gt;&gt;&gt; for f in fc.values():\n...     m = pd.Series([True, False] * (len(f.tracking.data)//2 + 1))[:len(f.tracking.data)]\n...     m.index = f.tracking.data.index\n...     f.store(m, 'mask', meta={})\n&gt;&gt;&gt; sc = SummaryCollection.from_features_collection(fc)\n&gt;&gt;&gt; rd = {h: s.time_true('mask') for h, s in sc.items()}\n&gt;&gt;&gt; sc.store(rd, name='t_mask')\n&gt;&gt;&gt; all('t_mask' in s.data for s in sc.values())\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.bfa","title":"bfa","text":"<pre><code>bfa(column: str, all_states=None, numshuffles: int = 1000)\n</code></pre> <p>Behaviour Flow Analysis between groups for a grouped SummaryCollection.</p> <p>Requires the collection to be grouped (via groupby). Computes transition matrices per Summary within each group, then computes Manhattan distances between group means and surrogate distributions via shuffling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; from py3r.behaviour.features.features_collection import FeaturesCollection\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; # inject simple 2-state labels and tags to build groups\n&gt;&gt;&gt; for i, (h, f) in enumerate(fc.items()):\n...     states = pd.Series(['A','A','B','B','A'] * (len(f.tracking.data)//5 + 1))[:len(f.tracking.data)]\n...     states.index = f.tracking.data.index\n...     f.store(states, 'state', meta={})\n...     f.tracking.add_tag('group', f'G{i+1}')\n&gt;&gt;&gt; gfc = fc.groupby('group')\n&gt;&gt;&gt; sc = SummaryCollection.from_features_collection(gfc)\n&gt;&gt;&gt; res = sc.bfa('state', all_states=['A','B'], numshuffles=2)\n&gt;&gt;&gt; isinstance(res, dict) and 'observed' in next(iter(res.values()))\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.bfa_stats","title":"bfa_stats  <code>staticmethod</code>","text":"<pre><code>bfa_stats(bfa_results: dict[str, dict[str, float]]) -&gt; dict[str, dict[str, float]]\n</code></pre> <p>Compute simple statistics (percentile, zscore, right_tail_p) from bfa results.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; from py3r.behaviour.features.features_collection import FeaturesCollection\n&gt;&gt;&gt; from py3r.behaviour.summary.summary_collection import SummaryCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv'); _ = shutil.copy(p, d / 'B.csv')\n...     tc = TrackingCollection.from_dlc({'A': str(d/'A.csv'), 'B': str(d/'B.csv')}, fps=30)\n&gt;&gt;&gt; fc = FeaturesCollection.from_tracking_collection(tc)\n&gt;&gt;&gt; for i, (h, f) in enumerate(fc.items()):\n...     states = pd.Series(['A','A','B','B','A'] * (len(f.tracking.data)//5 + 1))[:len(f.tracking.data)]\n...     states.index = f.tracking.data.index\n...     f.store(states, 'state', meta={})\n...     f.tracking.add_tag('group', f'G{i+1}')\n&gt;&gt;&gt; sc = SummaryCollection.from_features_collection(fc.groupby('group'))\n&gt;&gt;&gt; bfa_out = sc.bfa('state', all_states=['A','B'], numshuffles=2)\n&gt;&gt;&gt; stats = SummaryCollection.bfa_stats(bfa_out)\n&gt;&gt;&gt; set(next(iter(stats.values())).keys()) &gt;= {'percentile','zscore','right_tail_p'}\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.save","title":"save","text":"<pre><code>save(dirpath: str, *, overwrite: bool = False, data_format: str = 'parquet') -&gt; None\n</code></pre> <p>Save this collection to a directory. Preserves grouping and delegates to leaf objects' save(dirpath, data_format, overwrite=True).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, os\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     out = d / 'coll'\n...     coll.save(str(out), overwrite=True, data_format='csv')\n...     # collection-level manifest at top-level\n...     assert os.path.exists(os.path.join(str(out), 'manifest.json'))\n...     # element-level manifests under elements/&lt;handle&gt;/\n...     assert os.path.exists(os.path.join(str(out), 'elements', 'A', 'manifest.json'))\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.count_onset","title":"count_onset","text":"<pre><code>count_onset(column: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.count_onset across the collection.</p> <p>counts number of times boolean series in the given column changes from False to True, ignoring nan values if first non nan value in series is true, this counts as an onset</p> <p>See <code>Summary.count_onset</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.time_true","title":"time_true","text":"<pre><code>time_true(column: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.time_true across the collection.</p> <p>See <code>Summary.time_true</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.time_false","title":"time_false","text":"<pre><code>time_false(column: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.time_false across the collection.</p> <p>See <code>Summary.time_false</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.total_distance","title":"total_distance","text":"<pre><code>total_distance(point: str, startframe: int | None = None, endframe: int | None = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.total_distance across the collection.</p> <p>See <code>Summary.total_distance</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.sum_column","title":"sum_column","text":"<pre><code>sum_column(column: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.sum_column across the collection.</p> <p>Sum all non-NaN values in a <code>features.data</code> column and return as a SummaryResult.</p> <p>See <code>Summary.sum_column</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.transition_matrix","title":"transition_matrix","text":"<pre><code>transition_matrix(column: str, all_states=None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.transition_matrix across the collection.</p> <p>See <code>Summary.transition_matrix</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.count_state_onsets","title":"count_state_onsets","text":"<pre><code>count_state_onsets(column: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.count_state_onsets across the collection.</p> <p>counts the number of times a state is entered in a given column</p> <p>See <code>Summary.count_state_onsets</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.time_in_state","title":"time_in_state","text":"<pre><code>time_in_state(column: str) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Summary.time_in_state across the collection.</p> <p>See <code>Summary.time_in_state</code> for examples.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Values iterator (elements or sub-collections).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; len(list(coll.values())) == 2\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Items iterator (handle, element).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sorted([h for h, _ in coll.items()])\n['A', 'B']\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Keys iterator (handles or group keys).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; list(sorted(coll.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.groupby","title":"groupby","text":"<pre><code>groupby(tags)\n</code></pre> <p>Group the collection by one or more existing tag names. Returns a grouped view (this same collection type) whose values are sub-collections keyed by a tuple of tag values in the order provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; g.is_grouped\nTrue\n&gt;&gt;&gt; sorted(g.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.flatten","title":"flatten","text":"<pre><code>flatten()\n</code></pre> <p>Flatten a MultipleCollection to a flat Collection. If already flat, return self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G1')\n...     g = coll.groupby('group')\n&gt;&gt;&gt; flat = g.flatten()\n&gt;&gt;&gt; flat.is_grouped\nFalse\n&gt;&gt;&gt; sorted(flat.keys())\n['A', 'B']\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.get_group","title":"get_group","text":"<pre><code>get_group(key)\n</code></pre> <p>Get a sub-collection by group key from a grouped view.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; sub = g.get_group(('G1',))\n&gt;&gt;&gt; list(sub.keys())\n['A']\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.regroup","title":"regroup","text":"<pre><code>regroup()\n</code></pre> <p>Recompute the same grouping using the current tags and the original grouping tag order. If not grouped, returns self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G1')\n...     g = coll.groupby('group')\n...     coll['B'].add_tag('group','G2', overwrite=True)  # change tag\n&gt;&gt;&gt; g2 = g.regroup()\n&gt;&gt;&gt; sorted(g2.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.map_leaves","title":"map_leaves","text":"<pre><code>map_leaves(fn)\n</code></pre> <p>Apply a function to every leaf element and return a new collection of the same type. Preserves grouping shape and groupby metadata when grouped.</p> <p>fn: callable(Element) -&gt; ElementLike</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sub = coll.map_leaves(lambda t: t.loc[0:1])\n&gt;&gt;&gt; all(len(t.data) == 2 for t in sub.values())\nTrue\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str)\n</code></pre> <p>Load a collection previously saved with save(). Uses the class's _element_type.load to reconstruct leaves.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     out = d / 'coll'\n...     coll.save(str(out), overwrite=True, data_format='csv')\n...     coll2 = TrackingCollection.load(str(out))\n&gt;&gt;&gt; list(sorted(coll2.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/tracking/","title":"Tracking","text":""},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking","title":"py3r.behaviour.tracking.tracking.Tracking","text":"<pre><code>Tracking(data: DataFrame, meta: Dict[str, Any], handle: str, tags: dict[str, str] = None)\n</code></pre> <p>Represent frame-by-frame tracked keypoints with convenience loaders and tools.</p> <p>A <code>Tracking</code> holds a pandas DataFrame of columns like <code>p1.x</code>, <code>p1.y</code>, <code>p1.z</code>, <code>p1.likelihood</code> with index named <code>frame</code>. Most users create objects via factory methods and then call instance methods to process or analyze trajectories.</p> <p>Quick start with realistic CSVs stored in the package data:</p> <ul> <li>Load from DLC CSV</li> <li>Load from DLC multi-animal CSV</li> <li>Load from YOLO3R CSV</li> <li>Inspect points, distances</li> <li>Filter, interpolate, smooth</li> <li>Rescale by known distance, trim, check time</li> <li>Save and slice (<code>loc</code> / <code>iloc</code>)</li> <li>Minimal plotting</li> </ul> <p>Examples: Minimal DLC example:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; len(t.data), t.meta['fps'], t.handle\n(5, 30.0, 'ex')\n&gt;&gt;&gt; t.data[['p1.x','p1.y','p1.z','p1.likelihood']].head(2).reset_index().values.tolist()\n[[0.0, 0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 2.0, 3.0, 0.75]]\n</code></pre> <p>Load from DLC multi-animal (DLCMA):</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p_ma:\n...     tma = Tracking.from_dlcma(str(p_ma), handle='ma', fps=30)\n&gt;&gt;&gt; tma.meta['fps'], tma.handle\n(30.0, 'ma')\n</code></pre> <p>Load from YOLO3R (3D columns present):</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p_y:\n...     ty = Tracking.from_yolo3r(str(p_y), handle='y3r', fps=30)\n&gt;&gt;&gt; 'p1.z' in ty.data.columns and 'p1.likelihood' in ty.data.columns\nTrue\n&gt;&gt;&gt; ty.data[['p1.x','p1.y','p1.z','p1.likelihood']].head(2).reset_index().values.tolist()\n[[0.0, 0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 2.0, 3.0, 0.9]]\n</code></pre> <p>Inspect points and distances:</p> <pre><code>&gt;&gt;&gt; names = t.get_point_names()\n&gt;&gt;&gt; sorted(names)[:3]\n['p1', 'p2', 'p3']\n&gt;&gt;&gt; d = t.distance_between('p1', 'p2')\n&gt;&gt;&gt; len(d) == len(t.data)\nTrue\n</code></pre> <p>Filter low-likelihood positions and interpolate:</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t2 = Tracking.from_dlc(str(p), handle='ex2', fps=30)\n&gt;&gt;&gt; _ = t2.filter_likelihood(0.2)\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; bool(np.isnan(t2.data['p1.x']).any())\nTrue\n&gt;&gt;&gt; _ = t2.interpolate(method='nearest', limit=1)\n&gt;&gt;&gt; t2.data.columns.str.endswith('.likelihood').any() and t2.meta['interpolation']['method'] == 'nearest'\nTrue\n</code></pre> <p>Smooth all points with default window=3 rolling mean, and optional exception for point 'p1':</p> <pre><code>&gt;&gt;&gt; _ = t.smooth_all(3, 'mean',[(['p1'],'median',4)])\n&gt;&gt;&gt; 'smoothing' in t.meta\nTrue\n</code></pre> <p>Rescale by known distance between two points (uniform across dims):</p> <pre><code>&gt;&gt;&gt; _ = t.rescale_by_known_distance('p1', 'p2', distance_in_metres=2.0)\n&gt;&gt;&gt; t.meta['distance_units']\n'm'\n</code></pre> <p>Trim frames and verify time window:</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t3 = Tracking.from_dlc(str(p), handle='ex3', fps=30)\n&gt;&gt;&gt; _ = t3.trim(startframe=2, endframe=4)\n&gt;&gt;&gt; bool(t3.data.index[0] == 2 and t3.data.index[-1] == 4)\nTrue\n&gt;&gt;&gt; bool(t3.time_as_expected(mintime=0.0, maxtime=10.0))\nTrue\n</code></pre> <p>Save to a directory (parquet backend) and load back:</p> <pre><code>&gt;&gt;&gt; import os, tempfile\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     _ = t.save(d, data_format='csv',overwrite=True)\n...     t_loaded = Tracking.load(d)\n&gt;&gt;&gt; isinstance(t_loaded, Tracking) and len(t_loaded.data) == len(t.data)\nTrue\n</code></pre> <p>Slice with loc/iloc and keep handle:</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t4 = Tracking.from_dlc(str(p), handle='ex4', fps=30)\n&gt;&gt;&gt; t4s = t4.loc[0:3]\n&gt;&gt;&gt; isinstance(t4s, Tracking) and t4s.handle == 'ex4'\nTrue\n&gt;&gt;&gt; t4s2 = t4.iloc[0:2]\n&gt;&gt;&gt; isinstance(t4s2, Tracking) and len(t4s2.data) == 2\nTrue\n</code></pre> <p>Minimal plotting (no display):</p> <pre><code>&gt;&gt;&gt; _ = t.plot(show=False)\n</code></pre> <p>Tagging and user metadata:</p> <pre><code>&gt;&gt;&gt; t.add_tag('session', 'S1')\n&gt;&gt;&gt; t.tags['session']\n'S1'\n&gt;&gt;&gt; t.add_usermeta({'group': 'G1'}, overwrite=True)\n&gt;&gt;&gt; t.meta['usermeta']['group']\n'G1'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: DataFrame = data\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict = meta\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle: str = handle\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: dict[str, str] = tags if tags is not None else {}\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre> <p>Return a new Tracking object with self.data sliced by np.loc</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.data.shape\n(5, 12)\n&gt;&gt;&gt; t.loc[0:2,'p1.x'].data.shape\n(3,)\n&gt;&gt;&gt; t.loc[0:2].handle\n'ex'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre> <p>Return a new Tracking object with self.data sliced by np.iloc</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.data.shape\n(5, 12)\n&gt;&gt;&gt; t.iloc[0:2,0].data.shape\n(2,)\n&gt;&gt;&gt; t.iloc[0:2,0].handle\n'ex'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.from_dlc","title":"from_dlc  <code>classmethod</code>","text":"<pre><code>from_dlc(filepath: str | Path, *, handle: str, fps: float, aspectratio_correction: float = 1.0, tags: dict[str, str] | None = None) -&gt; Self\n</code></pre> <p>loads a Tracking object from a (single animal) deeplabcut tracking csv</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; len(t.data), t.meta['fps'], t.handle\n(5, 30.0, 'ex')\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.from_dlcma","title":"from_dlcma  <code>classmethod</code>","text":"<pre><code>from_dlcma(filepath: str | Path, *, handle: str, fps: float, aspectratio_correction: float = 1.0, tags: dict[str, str] | None = None) -&gt; Self\n</code></pre> <p>loads a Tracking object from a multi-animal deeplabcut tracking csv</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p:\n...     t = Tracking.from_dlcma(str(p), handle='ma', fps=30)\n&gt;&gt;&gt; len(t.data), t.meta['fps'], t.handle\n(4, 30.0, 'ma')\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.from_yolo3r","title":"from_yolo3r  <code>classmethod</code>","text":"<pre><code>from_yolo3r(filepath: str | Path, *, handle: str, fps: float, aspectratio_correction: float = 1.0, tags: dict[str, str] | None = None) -&gt; Self\n</code></pre> <p>loads a Tracking object from a single- or multi-animal yolo csv in 3R hub format</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p:\n...     t = Tracking.from_yolo3r(str(p), handle='y3r', fps=30)\n&gt;&gt;&gt; 'p1.z' in t.data.columns and 'p1.likelihood' in t.data.columns\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.add_usermeta","title":"add_usermeta","text":"<pre><code>add_usermeta(usermeta: dict, overwrite: bool = False) -&gt; None\n</code></pre> <p>adds or updates user-defined metadata</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.add_usermeta({'group': 'G1'}, overwrite=True)\n&gt;&gt;&gt; t.meta['usermeta']['group']\n'G1'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.add_tag","title":"add_tag","text":"<pre><code>add_tag(tagname: str, tagvalue: str, overwrite: bool = False) -&gt; None\n</code></pre> <p>adds or updates a tag</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.add_tag('session', 'S1', overwrite=True)\n&gt;&gt;&gt; t.tags['session']\n'S1'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.save","title":"save","text":"<pre><code>save(dirpath: str, *, data_format: str = 'parquet', overwrite: bool = False) -&gt; None\n</code></pre> <p>Save this Tracking into a self-describing directory for exact round-trip.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, os\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     t.save(d, data_format='csv', overwrite=True)\n...     os.path.exists(os.path.join(d, 'manifest.json'))\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str) -&gt; Self\n</code></pre> <p>Load a Tracking (or subclass) previously saved with save().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     t.save(d, data_format='csv', overwrite=True)\n...     t2 = Tracking.load(d)\n&gt;&gt;&gt; isinstance(t2, Tracking) and len(t2.data) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.strip_column_names","title":"strip_column_names","text":"<pre><code>strip_column_names() -&gt; None\n</code></pre> <p>strips out all column name string apart from last two sections delimited by dots</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; before = list(t.data.columns)[:3]\n&gt;&gt;&gt; t.strip_column_names()\n&gt;&gt;&gt; after = list(t.data.columns)[:3]\n&gt;&gt;&gt; all(len(c.split('.')) == 2 for c in after)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.time_as_expected","title":"time_as_expected","text":"<pre><code>time_as_expected(mintime: float, maxtime: float) -&gt; bool\n</code></pre> <p>checks that the total length of the tracking data is between mintime seconds and maxtime seconds</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; bool(t.time_as_expected(0.0, 1.0)) # between 0 and 1 second\nTrue\n&gt;&gt;&gt; bool(t.time_as_expected(0.0, 0.1)) # less than 0.1 seconds\nFalse\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.trim","title":"trim","text":"<pre><code>trim(startframe: int | None = None, endframe: int | None = None) -&gt; None\n</code></pre> <p>trims the tracking data object between startframe and endframe</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; _ = t.trim(1, 3)\n&gt;&gt;&gt; int(t.data.index[0]), int(t.data.index[-1])\n(1, 3)\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.filter_likelihood","title":"filter_likelihood","text":"<pre><code>filter_likelihood(threshold: float) -&gt; None\n</code></pre> <p>sets all tracking position values with likelihood less than threshold to np.nan</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.filter_likelihood(0.5)\n&gt;&gt;&gt; bool(np.isnan(t.data.filter(like='.x')).any().any())\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.distance_between","title":"distance_between","text":"<pre><code>distance_between(point1: str, point2: str, dims=('x', 'y')) -&gt; pd.Series\n</code></pre> <p>framewise distance between two points</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; d = t.distance_between('p1', 'p2')\n&gt;&gt;&gt; len(d) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.get_point_names","title":"get_point_names","text":"<pre><code>get_point_names() -&gt; list\n</code></pre> <p>list of tracked point names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; names = sorted(t.get_point_names())\n&gt;&gt;&gt; set(['p1','p2','p3']).issubset(names)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.rescale_by_known_distance","title":"rescale_by_known_distance","text":"<pre><code>rescale_by_known_distance(point1: str, point2: str, distance_in_metres: float, dims=('x', 'y')) -&gt; None\n</code></pre> <p>rescale all dims by known distance between two points</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.rescale_by_known_distance('p1','p2', 2.0)\n&gt;&gt;&gt; t.meta['distance_units']\n'm'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.generate_smoothdict","title":"generate_smoothdict","text":"<pre><code>generate_smoothdict(pointslists: list, windows: list, smoothtypes: list) -&gt; dict\n</code></pre> <p>deprecated, use smooth_all instead</p>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.smooth","title":"smooth","text":"<pre><code>smooth(smoothing_params: dict) -&gt; None\n</code></pre> <p>deprecated, use smooth_all instead</p>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.smooth_all","title":"smooth_all","text":"<pre><code>smooth_all(window: int | None = 3, method: str = 'mean', overrides: list[tuple[list[str] | tuple[str, ...] | str, str, int | None]] | None = None, dims: tuple[str, ...] = ('x', 'y'), strict: bool = False, inplace: bool = True, smoother=None, smoother_kwargs: dict | None = None) -&gt; 'Tracking | None'\n</code></pre> <p>Smooth all tracked points using a default method/window, with optional override groups.</p> <ul> <li>window/method: default applied to any point without override</li> <li>overrides: optional list of (points, method, window) tuples, where<ul> <li>points: list/tuple of point names (or a single str)</li> <li>method: 'median' or 'mean'</li> <li>window: int (or None to skip smoothing for those points)</li> </ul> </li> <li>dims: coordinate dimensions to smooth</li> <li>strict: require an effective window for every point</li> <li>inplace: mutate or return a new object</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.smooth_all(3, 'mean', overrides=[(['p1'], 'median', 4)])\n&gt;&gt;&gt; 'smoothing' in t.meta\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.interpolate","title":"interpolate","text":"<pre><code>interpolate(method: str = 'linear', limit: int = 1, **kwargs) -&gt; None\n</code></pre> <p>interpolates missing data in the tracking data, and sets likelihood to np.nan uses pandas.DataFrame.interpolate() with kwargs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.filter_likelihood(0.5)\n&gt;&gt;&gt; t.interpolate(method='linear', limit=1)\n&gt;&gt;&gt; 'interpolation' in t.meta\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.plot","title":"plot","text":"<pre><code>plot(trajectories=None, static=None, lines=None, dims=('x', 'y'), ax=None, title=None, show=True, elev=30, azim=45)\n</code></pre> <p>Plot trajectories and static points for this Tracking object. Args:     trajectories: list of point names or dict {point: color_series}     static: list of point names to plot as static (median)     lines: list of (point1, point2) pairs to join with a line     dims: tuple of dimension names (default ('x','y'); use ('x','y','z') for 3D)     ax: matplotlib axis (optional)     title: plot title (default: self.handle)     show: whether to call plt.show() Returns: fig, ax</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; _ = t.plot(show=False)\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.save_3d_tracking_video_multi_view","title":"save_3d_tracking_video_multi_view","text":"<pre><code>save_3d_tracking_video_multi_view(out_path: str, lines: list[tuple[str, str]] = None, point_size=40, line_width=2, point_color='b', line_color='k', dpi=150, writer='pillow', startframe=None, endframe=None, xlim=None, ylim=None, zlim=None, robust_percentile=1, invert_z=True)\n</code></pre> <p>Save a 3D animation of tracked points to a video file, with 4 subplots per frame: - azim=0, elev=0, ortho - azim=90, elev=0, ortho - azim=0, elev=90, ortho - azim=45, elev=30, persp Optionally, set axis limits manually or use robust percentiles to ignore outliers. Enforces equal aspect ratio for all axes.</p>"},{"location":"api/tracking_collection/","title":"TrackingCollection","text":""},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection","title":"py3r.behaviour.tracking.tracking_collection.TrackingCollection","text":"<pre><code>TrackingCollection(tracking_dict: dict[str, Tracking])\n</code></pre> <p>               Bases: <code>BaseCollection</code>, <code>TrackingCollectionBatchMixin</code></p> <p>Collection of Tracking objects, keyed by name (e.g. for grouping individuals) note: type-hints refer to Tracking, but factory methods allow for other classes these are intended ONLY for subclasses of Tracking, and this is enforced</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.tracking_dict","title":"tracking_dict  <code>property</code>","text":"<pre><code>tracking_dict\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre> <p>Slice all elements with Tracking object .loc and return a new collection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sub = coll.loc[0:2]\n&gt;&gt;&gt; all(len(t.data) == 3 for t in sub.values())\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre> <p>Slice all elements with Tracking object .iloc and return a new collection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sub = coll.iloc[0:2]\n&gt;&gt;&gt; all(len(t.data) == 2 for t in sub.values())\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.is_grouped","title":"is_grouped  <code>property</code>","text":"<pre><code>is_grouped\n</code></pre> <p>True if this collection is a grouped view.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; coll.is_grouped\nFalse\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.groupby_tags","title":"groupby_tags  <code>property</code>","text":"<pre><code>groupby_tags\n</code></pre> <p>The tag names used to form this grouped view (or None if flat).</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.group_keys","title":"group_keys  <code>property</code>","text":"<pre><code>group_keys\n</code></pre> <p>Keys for the groups in a grouped view. Empty list if not grouped.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; sorted(g.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_mapping","title":"from_mapping  <code>classmethod</code>","text":"<pre><code>from_mapping(handles_and_filepaths: dict[str, str], *, tracking_loader, tracking_cls=Tracking, **loader_kwargs)\n</code></pre> <p>Generic constructor from a mapping of handle -&gt; filepath using a loader callable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     # create two files for demonstration\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         f1 = d / 'a.csv'; f2 = d / 'b.csv'\n...         _ = shutil.copy(p, f1); _ = shutil.copy(p, f2)\n...     mapping = {'A': str(f1), 'B': str(f2)}\n...     coll = TrackingCollection.from_mapping(mapping, tracking_loader=Tracking.from_dlc, fps=30)\n&gt;&gt;&gt; sorted(coll.keys())\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlc","title":"from_dlc  <code>classmethod</code>","text":"<pre><code>from_dlc(handles_and_filepaths: dict[str, str], *, fps: float, aspectratio_correction: float = 1.0, tracking_cls=Tracking)\n</code></pre> <p>Load a collection from DLC CSVs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'a.csv'; b = d / 'b.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; len(coll)\n2\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_yolo3r","title":"from_yolo3r  <code>classmethod</code>","text":"<pre><code>from_yolo3r(handles_and_filepaths: dict[str, str], *, fps: float, aspectratio_correction: float = 1.0, tracking_cls=Tracking)\n</code></pre> <p>Load a collection from YOLO3R CSVs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p:\n...         a = d / 'a.csv'; b = d / 'b.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_yolo3r({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; set(coll.tracking_dict.keys()) == {'A','B'}\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlcma","title":"from_dlcma  <code>classmethod</code>","text":"<pre><code>from_dlcma(handles_and_filepaths: dict[str, str], *, fps: float, aspectratio_correction: float = 1.0, tracking_cls=Tracking)\n</code></pre> <p>Load a collection from DLC multi-animal CSVs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p:\n...         a = d / 'a.csv'; b = d / 'b.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlcma({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; len(coll) == 2\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dogfeather","title":"from_dogfeather  <code>classmethod</code>","text":"<pre><code>from_dogfeather(handles_and_filepaths: dict[str, str], *, fps: float, aspectratio_correction: float = 1.0, tracking_cls=Tracking)\n</code></pre> <p>Loads a TrackingCollection from a dict of dogfeather tracking csvs. handles_and_filepaths: dict mapping handles to file paths.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_folder","title":"from_folder  <code>classmethod</code>","text":"<pre><code>from_folder(folder_path: str, *, tracking_loader, tracking_cls: type = Tracking, **loader_kwargs) -&gt; TrackingCollection\n</code></pre> <p>Build a collection by scanning a folder for CSVs (or multi-view subfolders).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv')\n...         _ = shutil.copy(p, d / 'B.csv')\n...     coll = TrackingCollection.from_folder(str(d), tracking_loader=Tracking.from_dlc, fps=30)\n&gt;&gt;&gt; sorted(coll.keys())\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_yolo3r_folder","title":"from_yolo3r_folder  <code>classmethod</code>","text":"<pre><code>from_yolo3r_folder(folder_path: str, *, fps: float, aspectratio_correction: float = 1.0, tracking_cls: type = Tracking) -&gt; TrackingCollection\n</code></pre> <p>Convenience for from_folder using YOLO3R loader.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv')\n...         _ = shutil.copy(p, d / 'B.csv')\n...     coll = TrackingCollection.from_yolo3r_folder(str(d), fps=30)\n&gt;&gt;&gt; len(coll)\n2\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlc_folder","title":"from_dlc_folder  <code>classmethod</code>","text":"<pre><code>from_dlc_folder(folder_path: str, *, fps: float, aspectratio_correction: float = 1.0, tracking_cls: type = Tracking) -&gt; TrackingCollection\n</code></pre> <p>Convenience for from_folder using DLC loader.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv')\n...         _ = shutil.copy(p, d / 'B.csv')\n...     coll = TrackingCollection.from_dlc_folder(str(d), fps=30)\n&gt;&gt;&gt; set(coll.keys()) == {'A','B'}\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlcma_folder","title":"from_dlcma_folder  <code>classmethod</code>","text":"<pre><code>from_dlcma_folder(folder_path: str, *, fps: float, aspectratio_correction: float = 1.0, tracking_cls: type = Tracking) -&gt; TrackingCollection\n</code></pre> <p>Convenience for from_folder using DLCMA loader.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p:\n...         _ = shutil.copy(p, d / 'A.csv')\n...         _ = shutil.copy(p, d / 'B.csv')\n...     coll = TrackingCollection.from_dlcma_folder(str(d), fps=30)\n&gt;&gt;&gt; len(coll) == 2\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.add_tags_from_csv","title":"add_tags_from_csv","text":"<pre><code>add_tags_from_csv(csv_path: str) -&gt; None\n</code></pre> <p>Adds tags to all Tracking objects in the collection from a csv file. csv_path: path to a csv file with first column: \"handle\" and other columns with tagnames as titles and tagvalues as values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     # build a small collection\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     # tags csv\n...     tagcsv = d / 'tags.csv'\n...     pd.DataFrame([{'handle':'A','group':'G1'},{'handle':'B','group':'G2'}]).to_csv(tagcsv, index=False)\n...     coll.add_tags_from_csv(str(tagcsv))\n&gt;&gt;&gt; coll['A'].tags\n{'group': 'G1'}\n&gt;&gt;&gt; coll['B'].tags\n{'group': 'G2'}\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.stereo_triangulate","title":"stereo_triangulate","text":"<pre><code>stereo_triangulate() -&gt; TrackingCollection\n</code></pre> <p>Triangulate all TrackingMV objects and return a new TrackingCollection. The new collection will have the same grouping as the original.</p> Notes <p>This requires multi-view <code>TrackingMV</code> elements; typical <code>Tracking</code> elements do not support stereo triangulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, json\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_mv import TrackingMV\n&gt;&gt;&gt; # Create a collection with a single multi-view recording\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d) / 'rec1'\n...     d.mkdir(parents=True, exist_ok=True)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p_csv:\n...         _ = shutil.copy(p_csv, d / 'left.csv')\n...         _ = shutil.copy(p_csv, d / 'right.csv')\n...     # write a minimal synthetic calibration.json\n...     calib = {\n...         'view_order': ['left', 'right'],\n...         'views': {\n...             'left':  {'K': [[1,0,0],[0,1,0],[0,0,1]], 'dist': [0,0,0,0,0]},\n...             'right': {'K': [[1,0,0],[0,1,0],[0,0,1]], 'dist': [0,0,0,0,0]},\n...         },\n...         'relative_pose': {'R': [[1,0,0],[0,1,0],[0,0,1]], 'T': [0.1, 0.0, 0.0]},\n...     }\n...     (d / 'calibration.json').write_text(json.dumps(calib))\n...     # Build collection by scanning the parent folder with TrackingMV\n...     parent = str(d.parent)\n...     coll_mv = TrackingCollection.from_dlc_folder(parent, tracking_cls=TrackingMV, fps=30)\n...     coll_3d = coll_mv.stereo_triangulate()\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; isinstance(next(iter(coll_3d.values())), Tracking)\nTrue\n&gt;&gt;&gt; next(iter(coll_3d.keys()))\n'rec1'\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.plot","title":"plot","text":"<pre><code>plot(*args, **kwargs)\n</code></pre> <p>Plot all elements in the collection (or per group if grouped).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; _ = coll.plot(show=False)\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.add_usermeta","title":"add_usermeta","text":"<pre><code>add_usermeta(usermeta: dict, overwrite: bool = False) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.add_usermeta across the collection.</p> <p>adds or updates user-defined metadata</p> <p>See <code>Tracking.add_usermeta</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.add_tag","title":"add_tag","text":"<pre><code>add_tag(tagname: str, tagvalue: str, overwrite: bool = False) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.add_tag across the collection.</p> <p>adds or updates a tag</p> <p>See <code>Tracking.add_tag</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.save","title":"save","text":"<pre><code>save(dirpath: str, *, overwrite: bool = False, data_format: str = 'parquet') -&gt; None\n</code></pre> <p>Save this collection to a directory. Preserves grouping and delegates to leaf objects' save(dirpath, data_format, overwrite=True).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, os\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     out = d / 'coll'\n...     coll.save(str(out), overwrite=True, data_format='csv')\n...     # collection-level manifest at top-level\n...     assert os.path.exists(os.path.join(str(out), 'manifest.json'))\n...     # element-level manifests under elements/&lt;handle&gt;/\n...     assert os.path.exists(os.path.join(str(out), 'elements', 'A', 'manifest.json'))\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.strip_column_names","title":"strip_column_names","text":"<pre><code>strip_column_names() -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.strip_column_names across the collection.</p> <p>strips out all column name string apart from last two sections delimited by dots</p> <p>See <code>Tracking.strip_column_names</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.time_as_expected","title":"time_as_expected","text":"<pre><code>time_as_expected(mintime: float, maxtime: float) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.time_as_expected across the collection.</p> <p>checks that the total length of the tracking data is between mintime seconds and maxtime seconds</p> <p>See <code>Tracking.time_as_expected</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.trim","title":"trim","text":"<pre><code>trim(startframe: int | None = None, endframe: int | None = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.trim across the collection.</p> <p>trims the tracking data object between startframe and endframe</p> <p>See <code>Tracking.trim</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.filter_likelihood","title":"filter_likelihood","text":"<pre><code>filter_likelihood(threshold: float) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.filter_likelihood across the collection.</p> <p>sets all tracking position values with likelihood less than threshold to np.nan</p> <p>See <code>Tracking.filter_likelihood</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.distance_between","title":"distance_between","text":"<pre><code>distance_between(point1: str, point2: str, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.distance_between across the collection.</p> <p>framewise distance between two points</p> <p>See <code>Tracking.distance_between</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.get_point_names","title":"get_point_names","text":"<pre><code>get_point_names() -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.get_point_names across the collection.</p> <p>list of tracked point names</p> <p>See <code>Tracking.get_point_names</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.rescale_by_known_distance","title":"rescale_by_known_distance","text":"<pre><code>rescale_by_known_distance(point1: str, point2: str, distance_in_metres: float, dims=('x', 'y')) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.rescale_by_known_distance across the collection.</p> <p>rescale all dims by known distance between two points</p> <p>See <code>Tracking.rescale_by_known_distance</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.generate_smoothdict","title":"generate_smoothdict","text":"<pre><code>generate_smoothdict(pointslists: list, windows: list, smoothtypes: list) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.generate_smoothdict across the collection.</p> <p>deprecated, use smooth_all instead</p> <p>See <code>Tracking.generate_smoothdict</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.smooth","title":"smooth","text":"<pre><code>smooth(smoothing_params: dict) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.smooth across the collection.</p> <p>deprecated, use smooth_all instead</p> <p>See <code>Tracking.smooth</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.smooth_all","title":"smooth_all","text":"<pre><code>smooth_all(window: int | None = 3, method: str = 'mean', overrides: list[tuple[list[str] | tuple[str, ...] | str, str, int | None]] | None = None, dims: tuple[str, ...] = ('x', 'y'), strict: bool = False, inplace: bool = True, smoother=None, smoother_kwargs: dict | None = None) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.smooth_all across the collection.</p> <p>Smooth all tracked points using a default method/window, with optional override groups.</p> <p>See <code>Tracking.smooth_all</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.interpolate","title":"interpolate","text":"<pre><code>interpolate(method: str = 'linear', limit: int = 1, **kwargs) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.interpolate across the collection.</p> <p>interpolates missing data in the tracking data, and sets likelihood to np.nan uses pandas.DataFrame.interpolate() with kwargs</p> <p>See <code>Tracking.interpolate</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.save_3d_tracking_video_multi_view","title":"save_3d_tracking_video_multi_view","text":"<pre><code>save_3d_tracking_video_multi_view(out_path: str, lines: list[tuple[str, str]] = None, point_size=40, line_width=2, point_color='b', line_color='k', dpi=150, writer='pillow', startframe=None, endframe=None, xlim=None, ylim=None, zlim=None, robust_percentile=1, invert_z=True) -&gt; BatchResult\n</code></pre> <p>Batch-mode wrapper for Tracking.save_3d_tracking_video_multi_view across the collection.</p> <p>Save a 3D animation of tracked points to a video file, with 4 subplots per frame: - azim=0, elev=0, ortho - azim=90, elev=0, ortho - azim=0, elev=90, ortho - azim=45, elev=30, persp Optionally, set axis limits manually or use robust percentiles to ignore outliers. Enforces equal aspect ratio for all axes.</p> <p>See <code>Tracking.save_3d_tracking_video_multi_view</code> for examples.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Values iterator (elements or sub-collections).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; len(list(coll.values())) == 2\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Items iterator (handle, element).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sorted([h for h, _ in coll.items()])\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Keys iterator (handles or group keys).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; list(sorted(coll.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(objs)\n</code></pre> <p>Construct a collection from a list of items, using their .handle as the key. Raises a clear error if any item does not have a .handle attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t1 = Tracking.from_dlc(str(p), handle='A', fps=30)\n...     t2 = Tracking.from_dlc(str(p), handle='B', fps=30)\n&gt;&gt;&gt; coll = TrackingCollection.from_list([t1, t2])\n&gt;&gt;&gt; list(sorted(coll.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.groupby","title":"groupby","text":"<pre><code>groupby(tags)\n</code></pre> <p>Group the collection by one or more existing tag names. Returns a grouped view (this same collection type) whose values are sub-collections keyed by a tuple of tag values in the order provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; g.is_grouped\nTrue\n&gt;&gt;&gt; sorted(g.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.flatten","title":"flatten","text":"<pre><code>flatten()\n</code></pre> <p>Flatten a MultipleCollection to a flat Collection. If already flat, return self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G1')\n...     g = coll.groupby('group')\n&gt;&gt;&gt; flat = g.flatten()\n&gt;&gt;&gt; flat.is_grouped\nFalse\n&gt;&gt;&gt; sorted(flat.keys())\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.get_group","title":"get_group","text":"<pre><code>get_group(key)\n</code></pre> <p>Get a sub-collection by group key from a grouped view.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G2')\n&gt;&gt;&gt; g = coll.groupby('group')\n&gt;&gt;&gt; sub = g.get_group(('G1',))\n&gt;&gt;&gt; list(sub.keys())\n['A']\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.regroup","title":"regroup","text":"<pre><code>regroup()\n</code></pre> <p>Recompute the same grouping using the current tags and the original grouping tag order. If not grouped, returns self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     coll['A'].add_tag('group','G1'); coll['B'].add_tag('group','G1')\n...     g = coll.groupby('group')\n...     coll['B'].add_tag('group','G2', overwrite=True)  # change tag\n&gt;&gt;&gt; g2 = g.regroup()\n&gt;&gt;&gt; sorted(g2.group_keys)\n[('G1',), ('G2',)]\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.map_leaves","title":"map_leaves","text":"<pre><code>map_leaves(fn)\n</code></pre> <p>Apply a function to every leaf element and return a new collection of the same type. Preserves grouping shape and groupby metadata when grouped.</p> <p>fn: callable(Element) -&gt; ElementLike</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n&gt;&gt;&gt; sub = coll.map_leaves(lambda t: t.loc[0:1])\n&gt;&gt;&gt; all(len(t.data) == 2 for t in sub.values())\nTrue\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str)\n</code></pre> <p>Load a collection previously saved with save(). Uses the class's _element_type.load to reconstruct leaves.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking_collection import TrackingCollection\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...         a = d / 'A.csv'; b = d / 'B.csv'\n...         _ = shutil.copy(p, a); _ = shutil.copy(p, b)\n...     coll = TrackingCollection.from_dlc({'A': str(a), 'B': str(b)}, fps=30)\n...     out = d / 'coll'\n...     coll.save(str(out), overwrite=True, data_format='csv')\n...     coll2 = TrackingCollection.load(str(out))\n&gt;&gt;&gt; list(sorted(coll2.keys()))\n['A', 'B']\n</code></pre>"},{"location":"api/tracking_mv/","title":"TrackingMV","text":""},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV","title":"py3r.behaviour.tracking.tracking_mv.TrackingMV","text":"<pre><code>TrackingMV(views: dict[str, Tracking], calibration: dict, handle: str)\n</code></pre> <p>multi-view tracking object for stereo or multi-camera setups can be used as a drop-in replacement for Tracking in TrackingCollection stores dict of view name -&gt; Tracking, calibration, and handle</p>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.views","title":"views  <code>instance-attribute</code>","text":"<pre><code>views = views\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.calibration","title":"calibration  <code>instance-attribute</code>","text":"<pre><code>calibration = calibration\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle = handle\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_views","title":"from_views  <code>classmethod</code>","text":"<pre><code>from_views(filepaths: dict[str, str], handle: str, *, calibration: dict, tracking_loader, **loader_kwargs)\n</code></pre> <p>Loads a TrackingMV object from a dictionary of filepaths and a calibration dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, json\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     # two views using the same packaged CSV for simplicity\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p_csv:\n...         left = d / 'left.csv'; right = d / 'right.csv'\n...         _ = shutil.copy(p_csv, left); _ = shutil.copy(p_csv, right)\n...     # load a packaged calibration json (must define 'view_order' incl. 'left','right')\n...     with data_path('py3r.behaviour.tracking._data', 'calibration.json') as p_cal:\n...         calib = json.loads(Path(p_cal).read_text())\n...     mv = TrackingMV.from_views({'left': str(left), 'right': str(right)}, handle='rec1',\n...                                 calibration=calib, tracking_loader=Tracking.from_dlc, fps=30)\n&gt;&gt;&gt; isinstance(mv, TrackingMV) and set(mv.views.keys()) == {'left','right'}\nTrue\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_folder","title":"from_folder  <code>classmethod</code>","text":"<pre><code>from_folder(folder_path: str | Path, handle: str, *, tracking_loader, fps: float, aspectratio_correction: float = 1.0) -&gt; 'TrackingMV'\n</code></pre> <p>Build a TrackingMV from a folder containing view CSVs and calibration.json.</p>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_dlc","title":"from_dlc  <code>classmethod</code>","text":"<pre><code>from_dlc(folder_path: str | Path, handle: str, *, fps: float, aspectratio_correction: float = 1.0)\n</code></pre> <p>Build a TrackingMV from a folder containing DLC view CSVs and calibration.json.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, json\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p_csv:\n...         left = d / 'left.csv'; right = d / 'right.csv'\n...         _ = shutil.copy(p_csv, left); _ = shutil.copy(p_csv, right)\n...     calib = {'view_order':['left','right'],'views':{'left':{'K':[[1,0,0],[0,1,0],[0,0,1]],'dist':[0,0,0,0,0]},'right':{'K':[[1,0,0],[0,1,0],[0,0,1]],'dist':[0,0,0,0,0]}},'relative_pose':{'R':[[1,0,0],[0,1,0],[0,0,1]],'T':[0.1,0,0]}}\n...     (d/'calibration.json').write_text(json.dumps(calib))\n...     mv = TrackingMV.from_dlc(str(d), 'rec1', fps=30)\n&gt;&gt;&gt; isinstance(mv, TrackingMV)\nTrue\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_dlcma","title":"from_dlcma  <code>classmethod</code>","text":"<pre><code>from_dlcma(folder_path: str | Path, handle: str, *, fps: float, aspectratio_correction: float = 1.0)\n</code></pre> <p>Build a TrackingMV from a folder containing DLC multi-animal view CSVs and calibration.json.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, json\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p_csv:\n...         left = d / 'left.csv'; right = d / 'right.csv'\n...         _ = shutil.copy(p_csv, left); _ = shutil.copy(p_csv, right)\n...     calib = {'view_order':['left','right'],'views':{'left':{'K':[[1,0,0],[0,1,0],[0,0,1]],'dist':[0,0,0,0,0]},'right':{'K':[[1,0,0],[0,1,0],[0,0,1]],'dist':[0,0,0,0,0]}},'relative_pose':{'R':[[1,0,0],[0,1,0],[0,0,1]],'T':[0.1,0,0]}}\n...     (d/'calibration.json').write_text(json.dumps(calib))\n...     mv = TrackingMV.from_dlcma(str(d), 'rec1', fps=30)\n&gt;&gt;&gt; isinstance(mv, TrackingMV)\nTrue\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_yolo3r","title":"from_yolo3r  <code>classmethod</code>","text":"<pre><code>from_yolo3r(folder_path: str | Path, handle: str, *, fps: float, aspectratio_correction: float = 1.0)\n</code></pre> <p>Build a TrackingMV from a folder containing YOLO3R CSVs and calibration.json.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, shutil, json\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     d = Path(d)\n...     with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p_csv:\n...         left = d / 'left.csv'; right = d / 'right.csv'\n...         _ = shutil.copy(p_csv, left); _ = shutil.copy(p_csv, right)\n...     calib = {'view_order':['left','right'],'views':{'left':{'K':[[1,0,0],[0,1,0],[0,0,1]],'dist':[0,0,0,0,0]},'right':{'K':[[1,0,0],[0,1,0],[0,0,1]],'dist':[0,0,0,0,0]}},'relative_pose':{'R':[[1,0,0],[0,1,0],[0,0,1]],'T':[0.1,0,0]}}\n...     (d/'calibration.json').write_text(json.dumps(calib))\n...     mv = TrackingMV.from_yolo3r(str(d), 'rec1', fps=30)\n&gt;&gt;&gt; isinstance(mv, TrackingMV)\nTrue\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.stereo_triangulate","title":"stereo_triangulate","text":"<pre><code>stereo_triangulate(invert_z: bool = True) -&gt; 'Tracking'\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.align_ids_by_keypoints","title":"align_ids_by_keypoints","text":"<pre><code>align_ids_by_keypoints(keypoints: list[str], views: list[str] | None = None) -&gt; 'TrackingMV'\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.plot","title":"plot","text":"<pre><code>plot(trajectories=None, static=None, lines=None, dims=('x', 'y'), ax=None, title=None, show=True)\n</code></pre>"},{"location":"examples/epm_pipeline/","title":"EPM pipeline","text":"<p>End\u2011to\u2011end example computing various measures for different maze arms using folder\u2011based loaders, batch preprocessing, feature generation, and summary export. Paths are illustrative; adapt to your environment.</p> <pre><code># 1) Load a dataset of single\u2011view DLC CSVs into a TrackingCollection\nimport py3r.behaviour as p3b\n\nDATA_DIR = \"/data/recordings\"            # e.g. contains EPM_id1.csv, EPM_id2.csv, ...\nTAGS_CSV = \"/data/tags.csv\"              # optional, with columns: handle, treatment, genotype, ...\nOUT_DIR  = \"/outputs\"                    # where to save summary outputs\n\ntc = p3b.TrackingCollection.from_dlc_folder(folder_path=DATA_DIR, fps=30)\n\n# 2) (Optional) Add tags from a CSV for grouping/analysis\n# CSV must contain a 'handle' column matching filenames (without extension)\n# other column names are the tag names, and those column values are the tag values\n# e.g. handle, sex, treatment\n#      filename1, m, control\n#      filename2, f, crs\n#      ...etc\ntry:\n    tc.add_tags_from_csv(csv_path=TAGS_CSV)\nexcept FileNotFoundError:\n    pass\n\n# 3) Batch preprocessing of tracking files\n# Remove low-confidence detections (method/thresholds depend on your DLC export)\ntc.filter_likelihood(threshold=0.95)\n\n# Smooth all points with mean centre window 3, with exception for environment points\nenvironment_points = [\"tl\", \"tr\",\"ctr\",\"rt\",\"rb\",\"cbr\", \"br\", \"bl\",\"cbl\",\"lb\",\"lt\",\"ctl\"]\ntc.smooth_all(window=3, method=\"mean\", overrides=[(environment_points, \"median\", 30)])\n\n# Rescale distance to metres according to two corners of the EPM, here named 'tl' and 'br'\ntc.rescale_by_known_distance(point1=\"tl\", point2=\"br\", distance_in_metres=0.655)\n\n# Trim ends of recordings if needed\ntc.trim(endframe=-10*30)  # drop 10s from end at 30 fps\n\n# 4) Basic QA such as checking length of recordings and ploting tracking trajectories\n# Length check (per recording, assuming 5 min, time in seconds)\ntimecheck = tc.time_as_expected(mintime=300-(0.1*300) ,maxtime=300+(0.1*300))\nfor key, val in timecheck.items():\n    if not val:\n        raise Exception(f\"file {key} failed timecheck\")\n\n# Plot trajectories (per recording, using 'bodycentre' for trajectory of mouse and corners of EPM as static frame)\ntc.plot(trajectories=[\"bodycentre\"], static=environment_points, \n        lines=[(\"tl\", \"tr\"), (\"tr\", \"ctr\"), (\"ctr\", \"rt\"), (\"rt\", \"rb\"),\n               (\"rb\", \"cbr\"), (\"cbr\", \"br\"), (\"br\", \"bl\"), (\"bl\", \"cbl\"),\n               (\"cbl\", \"lb\"), (\"lb\", \"lt\"), (\"lt\", \"ctl\"), (\"ctl\", \"tl\")])\n\n# 5) Create FeaturesCollection object\nfc = p3b.FeaturesCollection.from_tracking_collection(tc)\n\n# 6) Compute features necessary to get different EPM measures \n# Define different boundaries (open arms, closed arms) and check if mouse (defined by 'bodycentre') is inside defined boundary\n# Adjust boundaries so they match orientation of your EPM.\n# Open arms\n_oa_boundary = fc.define_boundary(['tl', 'tr', 'ctr', 'ctl'], scaling=1.1, centre = [\"ctr\", \"ctl\"])\non_oa1 = fc.within_boundary_static(point=\"bodycentre\", boundary=_oa_boundary)\n_oa_boundary = fc.define_boundary(['cbl', 'cbr', 'br', 'bl'], scaling=1.1, centre = [\"cbr\", \"cbl\"])\non_oa2 = fc.within_boundary_static(point=\"bodycentre\", boundary=_oa_boundary)\non_oa = on_oa1 | on_oa2\non_oa.store(name=\"bodycentre_on_open_arms\")\n\ndist_change_on_oa = on_oa.astype(int) * fc.distance_change(\"bodycentre\")\ndist_change_on_oa.store(name=\"dist_change_bodycentre_on_oa\")\n\n# Closed arms\n_ca_boundary = fc.define_boundary([\"ctr\", \"rt\", \"rb\", \"cbr\"], scaling=1.1, centre = [\"ctr\", \"cbr\"])\non_ca1 = fc.within_boundary_static(point=\"bodycentre\", boundary=_ca_boundary)\n_ca_boundary = fc.define_boundary([\"lt\", \"ctl\", \"cbl\", \"lb\"], scaling=1.1, centre = [\"ctl\", \"cbl\"])\non_ca2 = fc.within_boundary_static(point=\"bodycentre\", boundary=_ca_boundary)\n# you can apply binary operators to BatchResult objects\non_ca = on_ca1 | on_ca2\non_oa.store(name=\"bodycentre_on_closed_arms\")\n\ndist_change_on_ca = on_ca.astype(int) * fc.distance_change(\"bodycentre\")\ndist_change_on_ca.store(name=\"dist_change_bodycentre_on_ca\")\n\n# 7) (Optional) Save features to csv\nfc.save(f\"{OUT_DIR}/features\", data_format=\"csv\", overwrite=True)\n\n# 8) Create SummaryCollection object\nsc = p3b.SummaryCollection.from_features_collection(fc)\n\n# 9) Compute summary measures per recording\n# Total distance moved\nsc.total_distance(\"bodycentre\").store()\n\n# Time on open arms\nsc.time_true(\"bodycentre_on_open_arms\").store(\"time_on_open_arms\")\n\n# Distance moved on open arms\nsc.sum_column(\"dist_change_bodycentre_on_oa\").store(name=\"distance_moved_on_open_arms\")\n\n# Time on closed arms\nsc.time_true(\"bodycentre_on_closed_arms\").store(\"time_on_closed_arms\")\n\n# Distance moved on closed arms\nsc.sum_column(\"dist_change_bodycentre_on_ca\").store(name=\"distance_moved_on_closed_arms\")\n\n# 10) Collate scalar outputs into DataFrame and save results in CSV\nsummary_df = sc.to_df(include_tags=True)\nsummary_df.to_csv(f\"{OUT_DIR}/EPM_results.csv\")\n</code></pre>"},{"location":"examples/grimace_pipeline_behaviourflow/","title":"GrimACE pipeline with BehaviourFlow","text":"<pre><code>import json\nimport numpy as np\nimport py3r.behaviour as p3b\n\nDATA_DIR = \"/data/recordings\"  # e.g. contains OFT_id1.csv, OFT_id2.csv, ...\nTAGS_CSV = \"/data/tags.csv\"  # optional, with columns: handle, treatment, genotype, ...\nOUT_DIR = \"/outputs\"  # where to save summary outputs\nRECORDING_LENGTH = 300  # seconds\n\n# Load the data into a TrackingCollection object\ntc = p3b.TrackingCollection.from_yolo3r_folder(folder_path=DATA_DIR, fps=30)\n\n# Strip the long prefixes from the column names in the data\ntc.strip_column_names()\n\n# Add tags from a CSV for grouping/analysis\n# CSV must contain a 'handle' column matching filenames (without extension)\n# other column names are the tag names, and those column values are the tag values\n# e.g. handle, sex, treatment\n#      filename1, m, control\n#      filename2, f, crs\n#      ...etc\ntry:\n    tc.add_tags_from_csv(csv_path=TAGS_CSV)\nexcept FileNotFoundError:\n    pass\n\n# 3) Batch preprocessing of tracking files\n# Remove low-confidence detections (method/thresholds depend on your DLC export)\ntc.filter_likelihood(threshold=0.6)\n\n# Smooth all points with mean centre window 3, with exception for environment points\ntc.smooth_all(\n    window=3, method=\"mean\", overrides=[([\"tr\", \"tl\", \"bl\", \"br\"], \"median\", 30)]\n)\n\n# Rescale distance to metres according to corners of the GrimACE arena, here named 'tl' and 'br'\ntc.rescale_by_known_distance(point1=\"tl\", point2=\"br\", distance_in_metres=0.13)\n\n# Basic QA such as checking length of recordings and ploting tracking trajectories\n# Length check (per recording, assuming 10 min, time in seconds)\ntimecheck = tc.time_as_expected(\n    mintime=RECORDING_LENGTH - (0.1 * RECORDING_LENGTH),\n    maxtime=RECORDING_LENGTH + (0.1 * RECORDING_LENGTH),\n)\nfor key, val in timecheck.items():\n    if not val:\n        raise ValueError(f\"file {key} failed timecheck\")\n\n# Plot trajectories (per recording, using 'bodycentre' for trajectory of mouse and corners of OFT as static frame)\ntc.plot(\n    trajectories=[\"bodycentre\"],\n    static=[\"tr\", \"tl\", \"bl\", \"br\"],\n    lines=[(\"tr\", \"tl\"), (\"tl\", \"bl\"), (\"bl\", \"br\"), (\"br\", \"tr\")],\n)\n\n# Create FeaturesCollection object\nfc = p3b.FeaturesCollection.from_tracking_collection(tc)\n\n# 6) Compute features to be used for BehaviourFlow analysis\n# (uncomment features to add to computation)\n# Note: adding features increases memory requirements\n\n# Accelerations\nfc.acceleration(\"nose\").store()\n# fc.acceleration(\"headcentre\").store()\nfc.acceleration(\"neck\").store()\n# fc.acceleration(\"earr\").store()\n# fc.acceleration(\"earl\").store()\nfc.acceleration(\"bodycentre\").store()\n# fc.acceleration(\"bcl\").store()\n# fc.acceleration(\"bcr\").store()\n# fc.acceleration(\"hipl\").store()\n# fc.acceleration(\"hipr\").store()\nfc.acceleration(\"tailbase\").store()\n\n# Angular deviations\n# fc.azimuth_deviation(\"tailbase\", \"hipr\", \"hipl\").store()\nfc.azimuth_deviation(\"bodycentre\", \"tailbase\", \"neck\").store()\nfc.azimuth_deviation(\"bodycentre\", \"bcr\", \"bcl\").store()\nfc.azimuth_deviation(\"neck\", \"bodycentre\", \"headcentre\").store()\n# fc.azimuth_deviation(\"bodycentre\", \"tailbase\", \"headcentre\").store()\n# fc.azimuth_deviation(\"bcl\", \"hipl\", \"earl\").store()\n# fc.azimuth_deviation(\"bcr\", \"hipr\", \"earr\").store()\n# fc.azimuth_deviation(\"nose\", \"earr\", \"earl\").store()\n\n# Distances\n# fc.distance_between(\"nose\", \"headcentre\").store()\nfc.distance_between(\"neck\", \"headcentre\").store()\nfc.distance_between(\"neck\", \"bodycentre\").store()\n# fc.distance_between(\"bcr\", \"bodycentre\").store()\n# fc.distance_between(\"bcl\", \"bodycentre\").store()\nfc.distance_between(\"tailbase\", \"bodycentre\").store()\n# fc.distance_between(\"tailbase\", \"hipr\").store()\n# fc.distance_between(\"tailbase\", \"hipl\").store()\n# fc.distance_between(\"bcr\", \"hipr\").store()\n# fc.distance_between(\"bcl\", \"hipl\").store()\n# fc.distance_between(\"bcl\", \"earl\").store()\n# fc.distance_between(\"bcr\", \"earr\").store()\n# fc.distance_between(\"nose\", \"earr\").store()\n# fc.distance_between(\"nose\", \"earl\").store()\n\n# Areas\n# fc.area_of_boundary([\"tailbase\", \"hipr\", \"hipl\"], median=False).store()\nfc.area_of_boundary([\"hipr\", \"hipl\", \"bcl\", \"bcr\"], median=False).store()\nfc.area_of_boundary([\"bcr\", \"earr\", \"earl\", \"bcl\"], median=False).store()\n# fc.area_of_boundary([\"earr\", \"nose\", \"earl\"], median=False).store()\n\n# Distance to GrimACE arena boundary\nbdry = fc.define_boundary([\"tl\", \"tr\", \"br\", \"bl\"], scaling=1.0)\n# fc.distance_to_boundary_static(\"nose\", bdry, boundary_name=\"grimacebox\").store()\nfc.distance_to_boundary_static(\"neck\", bdry, boundary_name=\"grimacebox\").store()\nfc.distance_to_boundary_static(\"bodycentre\", bdry, boundary_name=\"grimacebox\").store()\nfc.distance_to_boundary_static(\"tailbase\", bdry, boundary_name=\"grimacebox\").store()\n\n# (Optional) Save features to disk\nfc.save(f\"{OUT_DIR}/features\", data_format=\"csv\", overwrite=True)\n\n# Embed and cluster the features for BehaviourFlow analysis\nembedding_dict = {f: np.arange(-15, 16, 1) for f in fc[0].data.columns}\nlabels, centroids, norm = fc.cluster_embedding(\n    embedding_dict, n_clusters=25, lowmem=False, auto_normalize=True\n)\nlabels.store(name=\"km25_standard_norm\")\n\n# Create SummaryCollection object\nsc = p3b.SummaryCollection.from_features_collection(fc)\n\n# Compute summary measures per recording\n# Total distance moved\nsc.total_distance(\"bodycentre\").store()\n\n# 10) Collate scalar outputs into DataFrame and save results in CSV\nsummary_df = sc.to_df(include_tags=True)\nsummary_df.to_csv(f\"{OUT_DIR}/OFT_results.csv\")\n\n# Group the summary collection by tags for BehaviourFlow analysis\nsc_grouped = sc.groupby([\"treatment\", \"timepoint\"])\n\n# Perform BehaviourFlow analysis\nbfa_results = sc_grouped.bfa(\n    \"km25_standard_norm\", all_states=np.arange(0, 25, 1).astype(int), numshuffles=1000\n)\n\n# Save the BehaviourFlow analysis results\nwith open(f\"{OUT_DIR}/bfa_results.json\", \"w\") as f:\n    json.dump(bfa_results, f, indent=4)\n\n# Compute the statistics for the BehaviourFlow analysis\nbfa_stats = sc_grouped.bfa_stats(bfa_results)\n\n# Save the BehaviourFlow analysis statistics\nwith open(f\"{OUT_DIR}/bfa_stats.json\", \"w\") as f:\n    json.dump(bfa_stats, f, indent=4)\n</code></pre>"},{"location":"examples/oft_bfa_pipeline/","title":"OFT pipeline with BehaviourFlow","text":"<p>End\u2011to\u2011end example performing behavior segmentation and running behavior flow analysis (BFA) on k-means clustering results. The pipeline introduces folder\u2011based loaders, batch preprocessing, feature generation and embedding, k-means clustering, and performing BFA. Paths are illustrative; adapt to your environment.</p> <pre><code># 1) Load a dataset of single\u2011view DLC CSVs into a TrackingCollection\nimport json\nimport numpy as np\nimport py3r.behaviour as p3b\n\nDATA_DIR = \"/data/recordings\"            # e.g. contains OFT_id1.csv, OFT_id2.csv, ...\nTAGS_CSV = \"/data/tags.csv\"              # optional, with columns: handle, treatment, genotype, ...\nOUT_DIR  = \"/outputs\"                    # where to save summary outputs\nRECORDING_LENGTH = 600                   # seconds\n\ntc = p3b.TrackingCollection.from_dlc_folder(folder_path=DATA_DIR, fps=25)\n\n# 2) (Optional) Add tags from a CSV for grouping/analysis\n# CSV must contain a 'handle' column matching filenames (without extension)\n# other column names are the tag names, and those column values are the tag values\n# e.g. handle, sex, treatment\n#      filename1, m, control\n#      filename2, f, crs\n#      ...etc\ntry:\n    tc.add_tags_from_csv(csv_path=TAGS_CSV)\nexcept FileNotFoundError:\n    pass\n\n# 3) Batch preprocessing of tracking files\n# Remove low-confidence detections (method/thresholds depend on your DLC export)\ntc.filter_likelihood(threshold=0.95)\n\n# Smooth all points with mean centre window 3, with exception for environment points\ntc.smooth_all(window=3, method='mean', overrides=[([\"tr\", \"tl\", \"bl\", \"br\"], \"median\", 30)])\n\n# Rescale distance to metres according to corners of the OFT, here named 'tl' and 'br'\ntc.rescale_by_known_distance(point1='tl', point2='br', distance_in_metres=0.64)\n\n# Trim ends of recordings if needed\ntc.trim(endframe=-10*30)  # drop 10s from end at 30 fps\n\n# 4) Basic QA such as checking length of recordings and ploting tracking trajectories\n# Length check (per recording, assuming 10 min, time in seconds)\ntimecheck = tc.time_as_expected(mintime=RECORDING_LENGTH-(0.1*RECORDING_LENGTH),\n                                maxtime=RECORDING_LENGTH+(0.1*RECORDING_LENGTH))\nfor key, val in timecheck.items():\n    if not val:\n        raise Exception(f\"file {key} failed timecheck\")\n\n# Plot trajectories (per recording, using 'bodycentre' for trajectory of mouse and corners of OFT as static frame)\ntc.plot(trajectories=[\"bodycentre\"], static=[\"tr\", \"tl\", \"bl\", \"br\"],\n        lines=[(\"tr\",\"tl\"), (\"tl\",\"bl\"), (\"bl\",\"br\"), (\"br\",\"tr\")])\n\n# 5) Create FeaturesCollection object\nfc = p3b.FeaturesCollection.from_tracking_collection(tc)\n\n# 6) Compute features which will used for clustering\n# The following features are exemplary, adjust accordingly.\n# Speed of different keypoints\nfc.speed(\"nose\").store()\nfc.speed(\"neck\").store()\nfc.speed(\"earr\").store()\nfc.speed(\"earl\").store()\nfc.speed(\"bodycentre\").store()\nfc.speed(\"hipl\").store()\nfc.speed(\"hipr\").store()\nfc.speed(\"tailbase\").store()\n# Angle deviations\nfc.azimuth_deviation(\"tailbase\", \"hipr\", \"hipl\").store()\nfc.azimuth_deviation(\"bodycentre\", \"tailbase\", \"neck\").store()\nfc.azimuth_deviation(\"neck\", \"bodycentre\", \"headcentre\").store()\nfc.azimuth_deviation(\"headcentre\", \"earr\", \"earl\").store()\n# Distance between two keypoints\nfc.distance_between(\"nose\", \"headcentre\").store()\nfc.distance_between(\"neck\", \"headcentre\").store()\nfc.distance_between(\"neck\", \"bodycentre\").store()\nfc.distance_between(\"bcr\", \"bodycentre\").store()\nfc.distance_between(\"bcl\", \"bodycentre\").store()\nfc.distance_between(\"tailbase\", \"bodycentre\").store()\nfc.distance_between(\"tailbase\", \"hipr\").store()\nfc.distance_between(\"tailbase\", \"hipl\").store()\nfc.distance_between(\"bcr\", \"hipr\").store()\nfc.distance_between(\"bcl\", \"hipl\").store()\nfc.distance_between(\"bcl\", \"earl\").store()\nfc.distance_between(\"bcr\", \"earr\").store()\nfc.distance_between(\"nose\", \"earr\").store()\nfc.distance_between(\"nose\", \"earl\").store()\n# Area spanned by three or four keypoints\nfc.area_of_boundary([\"tailbase\", \"hipr\", \"hipl\"], median=False).store()\nfc.area_of_boundary([\"hipr\", \"hipl\", \"bcl\", \"bcr\"], median=False).store()\nfc.area_of_boundary([\"bcr\", \"earr\", \"earl\", \"bcl\"], median=False).store()\nfc.area_of_boundary([\"earr\", \"nose\", \"earl\"], median=False).store()\n# Distance to OFT boundary\nbdry = fc.define_boundary([\"tl\", \"tr\", \"br\", \"bl\"], scaling=1.0)\nfc.distance_to_boundary_static(\"nose\", bdry, boundary_name=\"oft\").store()\nfc.distance_to_boundary_static(\"neck\", bdry, boundary_name=\"oft\").store()\nfc.distance_to_boundary_static(\"bodycentre\", bdry, boundary_name=\"oft\").store()\nfc.distance_to_boundary_static(\"tailbase\", bdry, boundary_name=\"oft\").store()\n\n# 7) (Optional) Save features to csv\nfc.save(f\"{OUT_DIR}/features\", data_format=\"csv\", overwrite=True)\n\n# 8) Create dictionary for feature embedding\nfeatures = fc[1].data.columns\noffset = list(np.arange(-15, 16, 1))\nembedding_dict = {f: offset for f in features}\n\n# 9) Cluster the embedded feature space using k-means clustering\n# The keyword n_clusters defines the number of clusters used.\ncluster_labels, centroids, _ = fc.cluster_embedding(embedding_dict=embedding_dict, n_clusters = 25)\ncluster_labels.store(\"kmeans_25\", overwrite=True)\n\n# 10) Create SummaryCollection object and group it by one or more pre-defined tags\nsc = p3b.SummaryCollection.from_features_collection(fc)\nsc = sc.groupby(tags=\"group\")\n\n# 11) Perform behavior flow analysis on clustering results and print result\n# Perform behavior flow analysis and save results\nbfa_results = sc.bfa(column = \"kmeans_25\", all_states = np.arange(0,25))\nprint(bfa_results)\nwith open(f\"{OUT_DIR}/bfa_results.json\", \"w\") as f:\n    json.dump(bfa_results, f, indent=4)\n\n# Compute the statistics and save the results\nbfa_stats = p3b.SummaryCollection.bfa_stats(bfa_results)\nprint(bfa_stats)\nwith open(f\"{OUT_DIR}/bfa_stats.json\", \"w\") as f:\n    json.dump(bfa_stats, f, indent=4)\n</code></pre>"},{"location":"examples/oft_pipeline/","title":"OFT pipeline","text":"<p>End\u2011to\u2011end example computing \"distance moved\" and \"time in center\" using folder\u2011based loaders, batch preprocessing, feature generation, and summary export. Paths are illustrative; adapt to your environment.</p> <pre><code># 1) Load a dataset of single\u2011view DLC CSVs into a TrackingCollection\nimport py3r.behaviour as p3b\n\nDATA_DIR = \"/data/recordings\"            # e.g. contains OFT_id1.csv, OFT_id2.csv, ...\nTAGS_CSV = \"/data/tags.csv\"              # optional, with columns: handle, treatment, genotype, ...\nOUT_DIR  = \"/outputs\"                    # where to save summary outputs\n\ntc = p3b.TrackingCollection.from_dlc_folder(folder_path=DATA_DIR, fps=30)\n\n# 2) (Optional) Add tags from a CSV for grouping/analysis\n# CSV must contain a 'handle' column matching filenames (without extension)\n# other column names are the tag names, and those column values are the tag values\n# e.g. handle, sex, treatment\n#      filename1, m, control\n#      filename2, f, crs\n#      ...etc\ntry:\n    tc.add_tags_from_csv(csv_path=TAGS_CSV)\nexcept FileNotFoundError:\n    pass\n\n# 3) Batch preprocessing of tracking files\n# Remove low-confidence detections (method/thresholds depend on your DLC export)\ntc.filter_likelihood(threshold=0.95)\n\n# Smooth all points with mean centre window 3, with exception for environment points\ntc.smooth_all(window=3, method='mean', overrides=[([\"tr\", \"tl\", \"bl\", \"br\"], \"median\", 30)])\n\n# Rescale distance to metres according to corners of the OFT, here named 'tl' and 'br'\ntc.rescale_by_known_distance(point1='tl', point2='br', distance_in_metres=0.64)\n\n# Trim ends of recordings if needed\ntc.trim(endframe=-10*30)  # drop 10s from end at 30 fps\n\n# 4) Basic QA such as checking length of recordings and ploting tracking trajectories\n# Length check (per recording, assuming 10 min, time in seconds)\ntimecheck = tc.time_as_expected(mintime=600-(0.1*600) ,maxtime=600+(0.1*600))\nfor key, val in timecheck.items():\n    if not val:\n        raise Exception(f\"file {key} failed timecheck\")\n\n# Plot trajectories (per recording, using 'bodycentre' for trajectory of mouse and corners of OFT as static frame)\ntc.plot(trajectories=[\"bodycentre\"], static=[\"tr\", \"tl\", \"bl\", \"br\"], \n        lines=[(\"tr\",\"tl\"), (\"tl\",\"bl\"), (\"bl\",\"br\"), (\"br\",\"tr\")])\n\n# 5) Create FeaturesCollection object\nfc = p3b.FeaturesCollection.from_tracking_collection(tc)\n\n# 6) Compute features necessary to compute time in center \n# Define boundary of center area and check if mouse (defined by 'bodycentre') is inside defined boundary\ncenter_boundary = fc.define_boundary([\"tl\", \"tr\", \"bl\", \"br\"], scaling=0.5)\nfc.within_boundary_static(point=\"bodycentre\", boundary=center_boundary, boundary_name=\"center\").store()\n\n# 7) (Optional) Save features to csv\nfc.save(f\"{OUT_DIR}/features\", data_format=\"csv\", overwrite=True)\n\n# 8) Create SummaryCollection object\nsc = p3b.SummaryCollection.from_features_collection(fc)\n\n# 9) Compute summary measures per recording\n# Total distance moved\nsc.total_distance(\"bodycentre\").store()\n\n# Time in center\nsc.time_true(\"within_boundary_static_bodycentre_in_center\").store(\"time_in_center\")\n\n# 10) Collate scalar outputs into DataFrame and save results in CSV\nsummary_df = sc.to_df(include_tags=True)\nsummary_df.to_csv(f\"{OUT_DIR}/OFT_results.csv\")\n</code></pre>"}]}