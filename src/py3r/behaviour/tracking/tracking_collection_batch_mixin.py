# AUTO-GENERATED FILE â€” DO NOT EDIT
# Generated by tools/gen_batch_mixins.py from src/py3r/behaviour/tracking/tracking.py
# Regenerate with: PYTHONPATH=src python -m tools.gen_batch_mixins
from __future__ import annotations

from py3r.behaviour.util.collection_utils import BatchResult

class TrackingCollectionBatchMixin:

    def add_usermeta(self, usermeta: dict, overwrite: bool=False) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.add_usermeta across the collection.

        adds or updates user-defined metadata

        See [`Tracking.add_usermeta`][py3r.behaviour.tracking.tracking.Tracking.add_usermeta] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'add_usermeta')(usermeta, overwrite))
        return self._invoke_batch("add_usermeta", usermeta, overwrite)

    def add_tag(self, tagname: str, tagvalue: str, overwrite: bool=False) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.add_tag across the collection.

        adds or updates a tag

        See [`Tracking.add_tag`][py3r.behaviour.tracking.tracking.Tracking.add_tag] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'add_tag')(tagname, tagvalue, overwrite))
        return self._invoke_batch("add_tag", tagname, tagvalue, overwrite)

    def save(self, dirpath: str, *, data_format: str="parquet", overwrite: bool=False) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.save across the collection.

        Save this Tracking into a self-describing directory for exact round-trip.

        See [`Tracking.save`][py3r.behaviour.tracking.tracking.Tracking.save] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'save')(dirpath, data_format=data_format, overwrite=overwrite))
        return self._invoke_batch("save", dirpath, data_format=data_format, overwrite=overwrite)

    def strip_column_names(self) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.strip_column_names across the collection.

        strips out all column name string apart from last two sections delimited by dots

        See [`Tracking.strip_column_names`][py3r.behaviour.tracking.tracking.Tracking.strip_column_names] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'strip_column_names')())
        return self._invoke_batch("strip_column_names")

    def time_as_expected(self, mintime: float, maxtime: float) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.time_as_expected across the collection.

        checks that the total length of the tracking data is between mintime seconds and maxtime seconds

        See [`Tracking.time_as_expected`][py3r.behaviour.tracking.tracking.Tracking.time_as_expected] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'time_as_expected')(mintime, maxtime))
        return self._invoke_batch("time_as_expected", mintime, maxtime)

    def trim(self, startframe: int | None=None, endframe: int | None=None) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.trim across the collection.

        trims the tracking data object between startframe and endframe

        See [`Tracking.trim`][py3r.behaviour.tracking.tracking.Tracking.trim] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'trim')(startframe, endframe))
        return self._invoke_batch("trim", startframe, endframe)

    def filter_likelihood(self, threshold: float) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.filter_likelihood across the collection.

        sets all tracking position values with likelihood less than threshold to np.nan

        See [`Tracking.filter_likelihood`][py3r.behaviour.tracking.tracking.Tracking.filter_likelihood] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'filter_likelihood')(threshold))
        return self._invoke_batch("filter_likelihood", threshold)

    def distance_between(self, point1: str, point2: str, dims=("x", "y")) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.distance_between across the collection.

        framewise distance between two points

        See [`Tracking.distance_between`][py3r.behaviour.tracking.tracking.Tracking.distance_between] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'distance_between')(point1, point2, dims))
        return self._invoke_batch("distance_between", point1, point2, dims)

    def get_point_names(self) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.get_point_names across the collection.

        list of tracked point names

        See [`Tracking.get_point_names`][py3r.behaviour.tracking.tracking.Tracking.get_point_names] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'get_point_names')())
        return self._invoke_batch("get_point_names")

    def rescale_by_known_distance(self, point1: str, point2: str, distance_in_metres: float, dims=("x", "y")) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.rescale_by_known_distance across the collection.

        rescale all dims by known distance between two points

        See [`Tracking.rescale_by_known_distance`][py3r.behaviour.tracking.tracking.Tracking.rescale_by_known_distance] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'rescale_by_known_distance')(point1, point2, distance_in_metres, dims))
        return self._invoke_batch("rescale_by_known_distance", point1, point2, distance_in_metres, dims)

    def generate_smoothdict(self, pointslists: list, windows: list, smoothtypes: list) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.generate_smoothdict across the collection.

        deprecated, use smooth_all instead

        See [`Tracking.generate_smoothdict`][py3r.behaviour.tracking.tracking.Tracking.generate_smoothdict] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'generate_smoothdict')(pointslists, windows, smoothtypes))
        return self._invoke_batch("generate_smoothdict", pointslists, windows, smoothtypes)

    def smooth(self, smoothing_params: dict) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.smooth across the collection.

        deprecated, use smooth_all instead

        See [`Tracking.smooth`][py3r.behaviour.tracking.tracking.Tracking.smooth] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'smooth')(smoothing_params))
        return self._invoke_batch("smooth", smoothing_params)

    def smooth_all(self, window: int | None=3, method: str="mean", overrides: list[tuple[list[str] | tuple[str, ...] | str, str, int | None]]
        | None=None, dims: tuple[str, ...]=("x", "y"), strict: bool=False, inplace: bool=True, smoother=None, smoother_kwargs: dict | None=None) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.smooth_all across the collection.

        Smooth all tracked points using a default method/window, with optional override groups.

        See [`Tracking.smooth_all`][py3r.behaviour.tracking.tracking.Tracking.smooth_all] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'smooth_all')(window, method, overrides, dims, strict, inplace, smoother, smoother_kwargs))
        return self._invoke_batch("smooth_all", window, method, overrides, dims, strict, inplace, smoother, smoother_kwargs)

    def interpolate(self, method: str="linear", limit: int=1, **kwargs) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.interpolate across the collection.

        interpolates missing data in the tracking data, and sets likelihood to np.nan
        uses pandas.DataFrame.interpolate() with kwargs

        See [`Tracking.interpolate`][py3r.behaviour.tracking.tracking.Tracking.interpolate] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'interpolate')(method, limit, **kwargs))
        return self._invoke_batch("interpolate", method, limit, **kwargs)

    def plot(self, trajectories=None, static=None, lines=None, dims=("x", "y"), ax=None, title=None, show=True, elev=30, azim=45) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.plot across the collection.

        Plot trajectories and static points for this Tracking object.
        Args:
            trajectories: list of point names or dict {point: color_series}
            static: list of point names to plot as static (median)
            lines: list of (point1, point2) pairs to join with a line
            dims: tuple of dimension names (default ('x','y'); use ('x','y','z') for 3D)
            ax: matplotlib axis (optional)
            title: plot title (default: self.handle)
            show: whether to call plt.show()

        See [`Tracking.plot`][py3r.behaviour.tracking.tracking.Tracking.plot] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'plot')(trajectories, static, lines, dims, ax, title, show, elev, azim))
        return self._invoke_batch("plot", trajectories, static, lines, dims, ax, title, show, elev, azim)

    def save_3d_tracking_video_multi_view(self, out_path: str, lines: list[tuple[str, str]]=None, point_size=40, line_width=2, point_color="b", line_color="k", dpi=150, writer="pillow", startframe=None, endframe=None, xlim=None, ylim=None, zlim=None, robust_percentile=1, invert_z=True) -> BatchResult:
        """
        Batch-mode wrapper for Tracking.save_3d_tracking_video_multi_view across the collection.

        Save a 3D animation of tracked points to a video file, with 4 subplots per frame:
        - azim=0, elev=0, ortho
        - azim=90, elev=0, ortho
        - azim=0, elev=90, ortho
        - azim=45, elev=30, persp
        Optionally, set axis limits manually or use robust percentiles to ignore outliers.
        Enforces equal aspect ratio for all axes.

        See [`Tracking.save_3d_tracking_video_multi_view`][py3r.behaviour.tracking.tracking.Tracking.save_3d_tracking_video_multi_view] for examples.
        """
        _inplace = locals().get('inplace', True)
        if _inplace is False:
            return self.map_leaves(lambda _obj: getattr(_obj, 'save_3d_tracking_video_multi_view')(out_path, lines, point_size, line_width, point_color, line_color, dpi, writer, startframe, endframe, xlim, ylim, zlim, robust_percentile, invert_z))
        return self._invoke_batch("save_3d_tracking_video_multi_view", out_path, lines, point_size, line_width, point_color, line_color, dpi, writer, startframe, endframe, xlim, ylim, zlim, robust_percentile, invert_z)

