{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#py3r-behaviour","title":"py3r-behaviour","text":"<p>High-level behavioural analysis utilities for tracking, features, summaries, and classifiers in the py3r namespace.</p> <ul> <li>Install dev docs deps: mkdocs, mkdocs-material, mkdocstrings[python]</li> <li>Build: <code>mkdocs build</code></li> <li>Serve locally: <code>mkdocs serve</code></li> </ul>"},{"location":"#api","title":"API","text":"<p>See the API reference for the core packages and classes.</p>"},{"location":"api/features/","title":"Features","text":""},{"location":"api/features/#py3r.behaviour.features.features.Features","title":"py3r.behaviour.features.features.Features","text":"<pre><code>Features(tracking: Tracking)\n</code></pre> <p>generates features from a pre-processed Tracking object</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.tracking","title":"tracking  <code>instance-attribute</code>","text":"<pre><code>tracking = tracking\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = DataFrame()\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta = dict()\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle = handle\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.save","title":"save","text":"<pre><code>save(\n    dirpath: str,\n    *,\n    data_format: str = \"parquet\",\n    overwrite: bool = False\n) -&gt; None\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str) -&gt; 'Features'\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_between","title":"distance_between","text":"<pre><code>distance_between(\n    point1: str, point2: str, dims=(\"x\", \"y\")\n) -&gt; FeaturesResult\n</code></pre> <p>returns distance from point1 to point2</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_distance","title":"within_distance","text":"<pre><code>within_distance(\n    point1: str,\n    point2: str,\n    distance: float,\n    dims=(\"x\", \"y\"),\n) -&gt; FeaturesResult\n</code></pre> <p>returns True for frames where point1 is within specified distance of point2</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.get_point_median","title":"get_point_median","text":"<pre><code>get_point_median(point: str, dims=('x', 'y')) -&gt; tuple\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.define_boundary","title":"define_boundary","text":"<pre><code>define_boundary(\n    points: list[str],\n    scaling: float,\n    scaling_y: float = None,\n    centre: str | list[str] = None,\n) -&gt; list[tuple[float, float]]\n</code></pre> <p>takes a list of defined points, and creates a static rescaled list of point coordinates based on median location of those points 'centre' (point about which to scale) can be a string or list of strings, in which case the median of the points will be used as the centre if 'centre' is None, the median of all the boundary points will be used as the centre 'scaling' is the factor by which to scale the boundary points, and 'scaling_y' is the factor by which to scale the y-axis if 'scaling_y' is not provided, 'scaling' will be applied to both axes</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_boundary_static","title":"within_boundary_static","text":"<pre><code>within_boundary_static(\n    point: str,\n    boundary: list[tuple[float, float]],\n    boundary_name: str = None,\n) -&gt; FeaturesResult\n</code></pre> <p>checks whether point is inside polygon defined by ordered list of boundary points boundary points must be specified as a list of numerical tuples</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_boundary_dynamic","title":"within_boundary_dynamic","text":"<pre><code>within_boundary_dynamic(\n    point: str,\n    boundary: list[str],\n    boundary_name: str = None,\n) -&gt; FeaturesResult\n</code></pre> <p>checks whether point is inside polygon defined by ordered list of boundary points boundary points must be specified as a list of names of tracked points</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_boundary","title":"within_boundary","text":"<pre><code>within_boundary(\n    point: str,\n    boundary: list,\n    median: bool = True,\n    boundary_name: str = None,\n) -&gt; FeaturesResult\n</code></pre> <p>deprecated: use within_boundary_static or within_boundary_dynamic instead checks whether point is inside polygon defined by ordered list of boundary points boundary points may either be specified as a list of numerical tuples, or as a list of names of tracked points. Optionally, pass boundary_name for a custom short name in the feature name/meta.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_to_boundary","title":"distance_to_boundary","text":"<pre><code>distance_to_boundary(\n    point: str,\n    boundary: list[str],\n    median: bool = True,\n    boundary_name: str = None,\n) -&gt; FeaturesResult\n</code></pre> <p>Deprecated: use distance_to_boundary_static or distance_to_boundary_dynamic instead returns distance from point to boundary Optionally, pass boundary_name for a custom short name in the feature name/meta.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_to_boundary_static","title":"distance_to_boundary_static","text":"<pre><code>distance_to_boundary_static(\n    point: str,\n    boundary: list[tuple[float, float]],\n    boundary_name: str = None,\n) -&gt; FeaturesResult\n</code></pre> <p>Returns distance from point to a static boundary defined by a list of (x, y) tuples. If boundary_name is provided, it overrides the automatic id. NaN is returned if the point or any boundary vertex is NaN.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_to_boundary_dynamic","title":"distance_to_boundary_dynamic","text":"<pre><code>distance_to_boundary_dynamic(\n    point: str,\n    boundary: list[str],\n    boundary_name: str | None = None,\n) -&gt; FeaturesResult\n</code></pre> <p>Returns distance from point to a dynamic boundary defined by a list of point names. If boundary_name is provided, it overrides the automatic id. NaN is returned if the point or any boundary vertex is NaN.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.area_of_boundary","title":"area_of_boundary","text":"<pre><code>area_of_boundary(\n    boundary: list[str], median: bool = True\n) -&gt; FeaturesResult\n</code></pre> <p>returns area of boundary as a FeaturesResult (constant for static, per-frame for dynamic)</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.acceleration","title":"acceleration","text":"<pre><code>acceleration(point: str, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns acceleration of point from previous frame to current frame, for each frame</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.azimuth","title":"azimuth","text":"<pre><code>azimuth(point1: str, point2: str) -&gt; FeaturesResult\n</code></pre> <p>returns azimuth in radians from tracked point1 to tracked point2 for each frame in the data, relative to the direction of the x-axis</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.azimuth_deviation","title":"azimuth_deviation","text":"<pre><code>azimuth_deviation(\n    basepoint: str,\n    pointdirection1: str,\n    pointdirection2: str,\n) -&gt; FeaturesResult\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.within_azimuth_deviation","title":"within_azimuth_deviation","text":"<pre><code>within_azimuth_deviation(\n    basepoint: str,\n    pointdirection1: str,\n    pointdirection2: str,\n    deviation: float,\n) -&gt; FeaturesResult\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.speed","title":"speed","text":"<pre><code>speed(point: str, dims=('x', 'y')) -&gt; FeaturesResult\n</code></pre> <p>returns average speed of point from previous frame to current frame, for each frame</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.above_speed","title":"above_speed","text":"<pre><code>above_speed(\n    point: str, speed: float, dims=(\"x\", \"y\")\n) -&gt; FeaturesResult\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.all_above_speed","title":"all_above_speed","text":"<pre><code>all_above_speed(\n    points: list, speed: float, dims=(\"x\", \"y\")\n) -&gt; FeaturesResult\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.below_speed","title":"below_speed","text":"<pre><code>below_speed(\n    point: str, speed: float, dims=(\"x\", \"y\")\n) -&gt; FeaturesResult\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.all_below_speed","title":"all_below_speed","text":"<pre><code>all_below_speed(\n    points: list, speed: float, dims=(\"x\", \"y\")\n) -&gt; FeaturesResult\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.distance_change","title":"distance_change","text":"<pre><code>distance_change(\n    point: str, dims=(\"x\", \"y\")\n) -&gt; FeaturesResult\n</code></pre> <p>returns unsigned distance moved by point from previous frame to current frame, for each frame</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.store","title":"store","text":"<pre><code>store(\n    feature: Series,\n    name: str,\n    overwrite: bool = False,\n    meta: dict = dict(),\n) -&gt; None\n</code></pre> <p>stores calculated feature with name and associated freeform metadata object</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.classify","title":"classify","text":"<pre><code>classify(classifier: BaseClassifier, **kwargs)\n</code></pre> <p>classify behaviour using a classifier with inputs from this Features object returns a FeaturesResult object with the classification result this means that the output of the classifier should be a pd.Series with the same index as this Features object</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.smooth","title":"smooth","text":"<pre><code>smooth(\n    name: str,\n    method: str,\n    window: int,\n    center: bool = True,\n    inplace: bool = False,\n) -&gt; pd.Series\n</code></pre> <p>smooths specified feature with specified method over rolling window. if inplace=True then feature will be directly edited and metadata updated method:     'median' : median of value in window, requires numerical series values     'mean' : mean of value in window, requires numerical series values     'mode' : mode value in window, works with numerical or non-numerical types     'block' : removes labels that occur in blocks of less than length window               and replaces them with value from previous block unless there is               no previous block, in which case replaced from next block after smoothing               note: all nan values will be filled using this method (dangerous!)</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.embedding_df","title":"embedding_df","text":"<pre><code>embedding_df(embedding: dict[str, list[int]])\n</code></pre> <p>generate a time series embedding dataframe with specified time shifts for each column, where embedding is a dict mapping column names to lists of shifts positive shift: value from the future (t+n) negative shift: value from the past (t-n)</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.assign_clusters_by_centroids","title":"assign_clusters_by_centroids","text":"<pre><code>assign_clusters_by_centroids(\n    embedding: dict[str, list[int]], centroids_df: DataFrame\n) -&gt; pd.Series\n</code></pre> <p>new_embed_df: (n_samples, n_features)  DataFrame of your new time-shifted embedding centroids_df: (n_clusters, n_features) DataFrame of cluster centers Returns a Series of cluster IDs (0..n_clusters-1) indexed like new_embed_df.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.train_knn_regressor","title":"train_knn_regressor","text":"<pre><code>train_knn_regressor(\n    *,\n    source_embedding: dict[str, list[int]],\n    target_embedding: dict[str, list[int]],\n    n_neighbors: int = 5,\n    normalize_source: bool = False,\n    **kwargs\n)\n</code></pre> <p>Train a KNN regressor to predict a target embedding from a feature embedding on this Features object. If normalize_source is True, normalize the source embedding before training and return the rescale factors. Returns the trained model, input columns, target columns, and (optionally) the rescale factors.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.predict_knn","title":"predict_knn","text":"<pre><code>predict_knn(\n    model: KNeighborsRegressor,\n    source_embedding: dict[str, list[int]],\n    target_embedding: dict[str, list[int]],\n    rescale_factors: dict = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Predict using a trained KNN regressor on this Features object. If rescale_factors is provided, normalize the source embedding before prediction. The prediction will match the shape and columns of self.embedding_df(target_embedding).</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.rms_error_between_embeddings","title":"rms_error_between_embeddings  <code>staticmethod</code>","text":"<pre><code>rms_error_between_embeddings(\n    ground_truth: DataFrame,\n    prediction: DataFrame,\n    rescale: dict | str = None,\n) -&gt; pd.Series\n</code></pre> <p>Compute the root mean squared error (RMS) for each row between two embedding DataFrames. If rescale is a dict, normalize both DataFrames using this dict before computing the error. If rescale == 'auto', compute normalization factors from ground_truth and apply to both DataFrames. Returns a Series indexed like the input DataFrames, with NaN for rows where either input has NaNs.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx)\n</code></pre>"},{"location":"api/features/#py3r.behaviour.features.features.Features.define_elliptical_boundary_from_params","title":"define_elliptical_boundary_from_params","text":"<pre><code>define_elliptical_boundary_from_params(\n    centre: str | list[str],\n    major_axis_length: float,\n    minor_axis_length: float,\n    angle_in_radians: float = 0.0,\n    n_points: int = 100,\n) -&gt; list[tuple[float, float]]\n</code></pre> <p>Generate a polygonal approximation of an ellipse as a list of (x, y) tuples, around <code>centre</code> using explicit parameters. <code>centre</code> can be a single point name or a list of point names. if <code>centre</code> is a list, the boundary will be centred on the mean of the median coordinates of the points.</p>"},{"location":"api/features/#py3r.behaviour.features.features.Features.define_elliptical_boundary_from_points","title":"define_elliptical_boundary_from_points","text":"<pre><code>define_elliptical_boundary_from_points(\n    points: list[str],\n    n_points: int = 100,\n    scaling: float = 1.0,\n    smallness_weight: float = 0.1,\n) -&gt; list[tuple[float, float]]\n</code></pre> <p>Fit an ellipse to the median coordinates of the given tracked points (at least 4) and return a polygonal approximation. After fitting, the ellipse is scaled by <code>scaling</code>.</p>"},{"location":"api/features_collection/","title":"FeaturesCollection","text":""},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection","title":"py3r.behaviour.features.features_collection.FeaturesCollection","text":"<pre><code>FeaturesCollection(features_dict: dict[str, Features])\n</code></pre> <p>               Bases: <code>BaseCollection</code>, <code>FeaturesCollectionBatchMixin</code></p> <p>Collection of Features objects, keyed by name. note: type-hints refer to Features, but factory methods allow for other classes these are intended ONLY for subclasses of Features, and this is enforced</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.features_dict","title":"features_dict  <code>property</code>","text":"<pre><code>features_dict\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.from_tracking_collection","title":"from_tracking_collection  <code>classmethod</code>","text":"<pre><code>from_tracking_collection(\n    tracking_collection: TrackingCollection,\n    feature_cls=Features,\n)\n</code></pre> <p>Create a FeaturesCollection from a TrackingCollection.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(features_list: list[Features])\n</code></pre> <p>Create a FeaturesCollection from a list of Features objects, keyed by handle</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.cluster_embedding","title":"cluster_embedding","text":"<pre><code>cluster_embedding(\n    embedding_dict: dict[str, list[int]],\n    n_clusters: int,\n    random_state: int = 0,\n    *,\n    auto_normalize: bool = False,\n    rescale_factors: dict | None = None,\n    lowmem: bool = False,\n    decimation_factor: int = 10,\n    custom_scaling: dict[str, dict] | None = None\n)\n</code></pre> <p>Perform k-means clustering using the specified embedding.</p> <p>Unified behaviour for flat and grouped collections. Returns a BatchResult mapping:   - grouped: {group_key: {feature_handle: FeaturesResult}}   - flat:    {feature_handle: FeaturesResult} along with (centroids, normalization_factors or None).</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.cross_predict_rms","title":"cross_predict_rms","text":"<pre><code>cross_predict_rms(\n    source_embedding: dict[str, list[int]],\n    target_embedding: dict[str, list[int]],\n    normalize_source: bool = False,\n    normalize_pred: dict | str = None,\n    set1: list | None = None,\n    set2: list | None = None,\n    predictor_cls=None,\n    predictor_kwargs=None,\n)\n</code></pre> <p>Cross-prediction over grouped collections.</p> <ul> <li>If grouped: computes within-group leave-one-out and between-group predictions.</li> <li>If flat: computes within-collection leave-one-out only.</li> </ul> <p>Returns a dict with keys:     'within': {group_key or 'flat': {handle: rms_series}}     'between': {fromA_to_B: {target_handle: rms_series}}  (grouped only)</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.plot_cross_predict_vs_within","title":"plot_cross_predict_vs_within  <code>staticmethod</code>","text":"<pre><code>plot_cross_predict_vs_within(\n    results, from_group, to_group, show=True\n)\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.plot_cross_predict_results","title":"plot_cross_predict_results  <code>staticmethod</code>","text":"<pre><code>plot_cross_predict_results(\n    results,\n    within_keys=None,\n    between_keys=None,\n    plot_type=\"bar\",\n    figsize=(10, 6),\n    show=True,\n)\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.dumbbell_plot_cross_predict","title":"dumbbell_plot_cross_predict  <code>staticmethod</code>","text":"<pre><code>dumbbell_plot_cross_predict(\n    results,\n    within_key,\n    between_key,\n    figsize=(3, 3),\n    show=True,\n)\n</code></pre>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.train_knn_regressor","title":"train_knn_regressor","text":"<pre><code>train_knn_regressor(\n    *,\n    source_embedding: dict[str, list[int]],\n    target_embedding: dict[str, list[int]],\n    predictor_cls=None,\n    predictor_kwargs=None,\n    normalize_source: bool = False,\n    **kwargs\n)\n</code></pre> <p>Train a regressor to predict a target embedding from a feature embedding on this Features object. Uses predictor_cls (default: KNNPredictor) and passes predictor_kwargs. If normalize_source is True, normalize the source embedding before training and return the rescale factors. Returns the trained model, input columns, target columns, and (optionally) the rescale factors.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.predict_knn","title":"predict_knn","text":"<pre><code>predict_knn(\n    model,\n    source_embedding: dict[str, list[int]],\n    target_embedding: dict[str, list[int]],\n    rescale_factors: dict = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Predict using a trained regressor on this Features object. If rescale_factors is provided, normalize the source embedding before prediction. The prediction will match the shape and columns of self.embedding_df(target_embedding).</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.plot","title":"plot","text":"<pre><code>plot(\n    arg=None,\n    figsize=(8, 2),\n    show: bool = True,\n    title: str = None,\n)\n</code></pre> <p>Plot features for all collections in the MultipleFeaturesCollection. - If arg is a BatchResult or dict: treat as batch result and plot for each collection. - Otherwise: treat as column name(s) or None and plot for each collection. - If title is provided, it will be used as the overall title for the figure.</p>"},{"location":"api/features_collection/#py3r.behaviour.features.features_collection.FeaturesCollection.store","title":"store","text":"<pre><code>store(\n    results_dict,\n    name: str = None,\n    meta: dict = None,\n    overwrite: bool = False,\n)\n</code></pre> <p>Store FeaturesResult objects returned by batch methods.</p> <ul> <li>Flat collection: results_dict is {handle: FeaturesResult}</li> <li>Grouped collection: results_dict is {group_key: {handle: FeaturesResult}}</li> </ul>"},{"location":"api/summary/","title":"Summary","text":""},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary","title":"py3r.behaviour.summary.summary.Summary","text":"<pre><code>Summary(trackingfeatures: Features)\n</code></pre> <p>stores and computes summary statistics from features objects</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.features","title":"features  <code>instance-attribute</code>","text":"<pre><code>features = trackingfeatures\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = dict()\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta = dict()\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle = handle\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.save","title":"save","text":"<pre><code>save(\n    dirpath: str,\n    *,\n    data_format: str = \"parquet\",\n    overwrite: bool = False\n) -&gt; None\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str) -&gt; 'Summary'\n</code></pre>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.count_onset","title":"count_onset","text":"<pre><code>count_onset(column: str) -&gt; SummaryResult\n</code></pre> <p>counts number of times boolean series in the given column changes from False to True, ignoring nan values if first non nan value in series is true, this counts as an onset</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.time_true","title":"time_true","text":"<pre><code>time_true(column: str) -&gt; SummaryResult\n</code></pre> <p>returns time in seconds that condition in the given column is true</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.time_false","title":"time_false","text":"<pre><code>time_false(column: str) -&gt; SummaryResult\n</code></pre> <p>returns time in seconds that condition in the given column is false</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.total_distance","title":"total_distance","text":"<pre><code>total_distance(\n    point: str,\n    startframe: int | None = None,\n    endframe: int | None = None,\n) -&gt; SummaryResult\n</code></pre> <p>returns total distance traveled by a tracked point between optional start and end frames</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.store","title":"store","text":"<pre><code>store(\n    summarystat: Any,\n    name: str,\n    overwrite: bool = False,\n    meta: Any = None,\n) -&gt; None\n</code></pre> <p>stores a summary statistic and optional metadata, with optional overwrite protection</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.make_bin","title":"make_bin","text":"<pre><code>make_bin(startframe: int, endframe: int) -&gt; 'Summary'\n</code></pre> <p>creates a copy of the Summary object with the dataframes restricted from startframe to endframe, inclusive</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.make_bins","title":"make_bins","text":"<pre><code>make_bins(numbins: int) -&gt; List[Summary]\n</code></pre> <p>creates a list of Summary objects, with frames restricted into numbins even intervals. start/endpoints are duplicated between intervals to ensure no loss in e.g. distance calculations</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.transition_matrix","title":"transition_matrix","text":"<pre><code>transition_matrix(\n    column: str, all_states=None\n) -&gt; SummaryResult\n</code></pre> <p>Returns a transition matrix for a given column in self.features.data, with rows and columns as the unique values of the column or as specified by all_states.</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.count_state_onsets","title":"count_state_onsets","text":"<pre><code>count_state_onsets(column: str) -&gt; SummaryResult\n</code></pre> <p>counts the number of times a state is entered in a given column</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.time_in_state","title":"time_in_state","text":"<pre><code>time_in_state(column: str) -&gt; SummaryResult\n</code></pre> <p>returns the time spent in each state in a given column</p>"},{"location":"api/summary/#py3r.behaviour.summary.summary.Summary.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre>"},{"location":"api/summary_collection/","title":"SummaryCollection","text":""},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection","title":"py3r.behaviour.summary.summary_collection.SummaryCollection","text":"<pre><code>SummaryCollection(summary_dict: dict[str, Summary])\n</code></pre> <p>               Bases: <code>BaseCollection</code>, <code>SummaryCollectionBatchMixin</code></p> <p>collection of Summary objects (e.g. for grouping individuals) note: type-hints refer to Summary, but factory methods allow for other classes these are intended ONLY for subclasses of Summary, and this is enforced</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.summary_dict","title":"summary_dict  <code>property</code>","text":"<pre><code>summary_dict\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.from_features_collection","title":"from_features_collection  <code>classmethod</code>","text":"<pre><code>from_features_collection(\n    features_collection: FeaturesCollection,\n    summary_cls=Summary,\n)\n</code></pre> <p>creates a SummaryCollection from a FeaturesCollection (flat or grouped)</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(summary_list: list[Summary])\n</code></pre> <p>creates a SummaryCollection from a list of Summary objects, keyed by handle</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.to_df","title":"to_df","text":"<pre><code>to_df(include_tags: bool = False, tag_prefix: str = 'tag_')\n</code></pre> <p>Collate scalar values (numeric, string, bool) from each Summary.data into a pandas DataFrame.</p> <ul> <li>Index: handles of the Summary objects</li> <li>Columns: keys from each Summary.data (simple scalar values)</li> <li>If include_tags is True, include tag columns with the given prefix</li> </ul>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.make_bin","title":"make_bin","text":"<pre><code>make_bin(startframe, endframe)\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.make_bins","title":"make_bins","text":"<pre><code>make_bins(numbins)\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.store","title":"store","text":"<pre><code>store(\n    results_dict: dict[str, SummaryResult],\n    name: str = None,\n    meta: dict = None,\n    overwrite: bool = False,\n)\n</code></pre> <p>Store all SummaryResult objects in a one-layer dict (as returned by batch methods). Example:     results = summary_collection.time_true('is_running')     summary_collection.store(results)</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.bfa","title":"bfa","text":"<pre><code>bfa(column: str, all_states=None, numshuffles: int = 1000)\n</code></pre> <p>Behaviour Flow Analysis between groups for a grouped SummaryCollection.</p> <p>Requires the collection to be grouped (via groupby). Computes transition matrices per Summary within each group, then computes Manhattan distances between group means and surrogate distributions via shuffling.</p>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.bfa_stats","title":"bfa_stats  <code>staticmethod</code>","text":"<pre><code>bfa_stats(\n    bfa_results: dict[str, dict[str, float]],\n) -&gt; dict[str, dict[str, float]]\n</code></pre>"},{"location":"api/summary_collection/#py3r.behaviour.summary.summary_collection.SummaryCollection.shuffle_lists","title":"shuffle_lists  <code>staticmethod</code>","text":"<pre><code>shuffle_lists(\n    group1: list, group2: list\n) -&gt; tuple[list, list]\n</code></pre>"},{"location":"api/tracking/","title":"Tracking","text":""},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking","title":"py3r.behaviour.tracking.tracking.Tracking","text":"<pre><code>Tracking(\n    data: DataFrame,\n    meta: Dict[str, Any],\n    handle: str,\n    tags: dict[str, str] = None,\n)\n</code></pre> <p>Represent frame-by-frame tracked keypoints with convenience loaders and tools.</p> <p>A <code>Tracking</code> holds a pandas DataFrame of columns like <code>p1.x</code>, <code>p1.y</code>, <code>p1.z</code>, <code>p1.likelihood</code> with index named <code>frame</code>. Most users create objects via factory methods and then call instance methods to process or analyze trajectories.</p> <p>Quick start with realistic CSVs stored in the package data:</p> <ul> <li>Load from DLC CSV</li> <li>Load from DLC multi-animal CSV</li> <li>Load from YOLO3R CSV</li> <li>Inspect points, distances</li> <li>Filter, interpolate, smooth</li> <li>Rescale by known distance, trim, check time</li> <li>Save and slice (<code>loc</code> / <code>iloc</code>)</li> <li>Minimal plotting</li> </ul> <p>Examples: Minimal DLC example:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; len(t.data), t.meta['fps'], t.handle\n(5, 30.0, 'ex')\n&gt;&gt;&gt; t.data[['p1.x','p1.y','p1.z','p1.likelihood']].head(2).reset_index().values.tolist()\n[[0.0, 0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 2.0, 3.0, 0.75]]\n</code></pre> <p>Load from DLC multi-animal (DLCMA):</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p_ma:\n...     tma = Tracking.from_dlcma(str(p_ma), handle='ma', fps=30)\n&gt;&gt;&gt; tma.meta['fps'], tma.handle\n(30.0, 'ma')\n</code></pre> <p>Load from YOLO3R (3D columns present):</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p_y:\n...     ty = Tracking.from_yolo3r(str(p_y), handle='y3r', fps=30)\n&gt;&gt;&gt; 'p1.z' in ty.data.columns and 'p1.likelihood' in ty.data.columns\nTrue\n&gt;&gt;&gt; ty.data[['p1.x','p1.y','p1.z','p1.likelihood']].head(2).reset_index().values.tolist()\n[[0.0, 0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 2.0, 3.0, 0.9]]\n</code></pre> <p>Inspect points and distances:</p> <pre><code>&gt;&gt;&gt; names = t.get_point_names()\n&gt;&gt;&gt; sorted(names)[:3]\n['p1', 'p2', 'p3']\n&gt;&gt;&gt; d = t.distance_between('p1', 'p2')\n&gt;&gt;&gt; len(d) == len(t.data)\nTrue\n</code></pre> <p>Filter low-likelihood positions and interpolate:</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t2 = Tracking.from_dlc(str(p), handle='ex2', fps=30)\n&gt;&gt;&gt; _ = t2.filter_likelihood(0.2)\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; bool(np.isnan(t2.data['p1.x']).any())\nTrue\n&gt;&gt;&gt; _ = t2.interpolate(method='nearest', limit=1)\n&gt;&gt;&gt; t2.data.columns.str.endswith('.likelihood').any() and t2.meta['interpolation']['method'] == 'nearest'\nTrue\n</code></pre> <p>Smooth all points with default window=3 rolling mean, and optional exception for point 'p1':</p> <pre><code>&gt;&gt;&gt; _ = t.smooth_all(3, 'mean',(['p1'],'median',4))\n&gt;&gt;&gt; 'smoothing' in t.meta\nTrue\n</code></pre> <p>Rescale by known distance between two points (uniform across dims):</p> <pre><code>&gt;&gt;&gt; _ = t.rescale_by_known_distance('p1', 'p2', distance_in_metres=2.0)\n&gt;&gt;&gt; t.meta['distance_units']\n'm'\n</code></pre> <p>Trim frames and verify time window:</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t3 = Tracking.from_dlc(str(p), handle='ex3', fps=30)\n&gt;&gt;&gt; _ = t3.trim(startframe=2, endframe=4)\n&gt;&gt;&gt; bool(t3.data.index[0] == 2 and t3.data.index[-1] == 4)\nTrue\n&gt;&gt;&gt; bool(t3.time_as_expected(mintime=0.0, maxtime=10.0))\nTrue\n</code></pre> <p>Save to a directory (parquet backend) and load back:</p> <pre><code>&gt;&gt;&gt; import os, tempfile\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     _ = t.save(d, overwrite=True)\n...     t_loaded = Tracking.load(d)\n&gt;&gt;&gt; isinstance(t_loaded, Tracking) and len(t_loaded.data) == len(t.data)\nTrue\n</code></pre> <p>Slice with loc/iloc and keep handle:</p> <pre><code>&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t4 = Tracking.from_dlc(str(p), handle='ex4', fps=30)\n&gt;&gt;&gt; t4s = t4.loc[0:3]\n&gt;&gt;&gt; isinstance(t4s, Tracking) and t4s.handle == 'ex4'\nTrue\n&gt;&gt;&gt; t4s2 = t4.iloc[0:2]\n&gt;&gt;&gt; isinstance(t4s2, Tracking) and len(t4s2.data) == 2\nTrue\n</code></pre> <p>Minimal plotting (no display):</p> <pre><code>&gt;&gt;&gt; _ = t.plot(show=False)\n</code></pre> <p>Tagging and user metadata:</p> <pre><code>&gt;&gt;&gt; t.add_tag('session', 'S1')\n&gt;&gt;&gt; t.tags['session']\n'S1'\n&gt;&gt;&gt; t.add_usermeta({'group': 'G1'}, overwrite=True)\n&gt;&gt;&gt; t.meta['usermeta']['group']\n'G1'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: DataFrame = data\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict = meta\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle: str = handle\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: dict[str, str] = tags if tags is not None else {}\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre> <p>Return a new Tracking object with self.data sliced by np.loc</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.shape\n(5, 3)\n&gt;&gt;&gt; t.loc[0:2,'p1.x'].data.shape\n(2, 1)\n&gt;&gt;&gt; t.loc[0:2].handle\n'ex'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre> <p>Return a new Tracking object with self.data sliced by np.iloc</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.shape\n(5, 3)\n&gt;&gt;&gt; t.iloc[0:2,0].data.shape\n(2, 1)\n&gt;&gt;&gt; t.iloc[0:2,0].handle\n'ex'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.from_dlc","title":"from_dlc  <code>classmethod</code>","text":"<pre><code>from_dlc(\n    filepath: str | Path,\n    *,\n    handle: str,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tags: dict[str, str] | None = None\n) -&gt; Self\n</code></pre> <p>loads a Tracking object from a (single animal) deeplabcut tracking csv</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; from py3r.behaviour.tracking.tracking import Tracking\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; len(t.data), t.meta['fps'], t.handle\n(5, 30.0, 'ex')\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.from_dlcma","title":"from_dlcma  <code>classmethod</code>","text":"<pre><code>from_dlcma(\n    filepath: str | Path,\n    *,\n    handle: str,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tags: dict[str, str] | None = None\n) -&gt; Self\n</code></pre> <p>loads a Tracking object from a multi-animal deeplabcut tracking csv</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlcma_multi.csv') as p:\n...     t = Tracking.from_dlcma(str(p), handle='ma', fps=30)\n&gt;&gt;&gt; len(t.data), t.meta['fps'], t.handle\n(5, 30.0, 'ma')\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.from_yolo3r","title":"from_yolo3r  <code>classmethod</code>","text":"<pre><code>from_yolo3r(\n    filepath: str | Path,\n    *,\n    handle: str,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tags: dict[str, str] | None = None\n) -&gt; Self\n</code></pre> <p>loads a Tracking object from a single- or multi-animal yolo csv in 3R hub format</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'yolo3r.csv') as p:\n...     t = Tracking.from_yolo3r(str(p), handle='y3r', fps=30)\n&gt;&gt;&gt; 'p1.z' in t.data.columns and 'p1.likelihood' in t.data.columns\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.add_usermeta","title":"add_usermeta","text":"<pre><code>add_usermeta(\n    usermeta: dict, overwrite: bool = False\n) -&gt; None\n</code></pre> <p>adds or updates user-defined metadata</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.add_usermeta({'group': 'G1'}, overwrite=True)\n&gt;&gt;&gt; t.meta['usermeta']['group']\n'G1'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.add_tag","title":"add_tag","text":"<pre><code>add_tag(\n    tagname: str, tagvalue: str, overwrite: bool = False\n) -&gt; None\n</code></pre> <p>adds or updates a tag</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.add_tag('session', 'S1', overwrite=True)\n&gt;&gt;&gt; t.tags['session']\n'S1'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.save","title":"save","text":"<pre><code>save(\n    dirpath: str,\n    *,\n    data_format: str = \"parquet\",\n    overwrite: bool = False\n) -&gt; None\n</code></pre> <p>Save this Tracking into a self-describing directory for exact round-trip.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile, os\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     t.save(d, data_format='parquet', overwrite=True)\n...     os.path.exists(os.path.join(d, 'manifest.json'))\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(dirpath: str) -&gt; Self\n</code></pre> <p>Load a Tracking (or subclass) previously saved with save().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as d:\n...     t.save(d, data_format='csv', overwrite=True)\n...     t2 = Tracking.load(d)\n&gt;&gt;&gt; isinstance(t2, Tracking) and len(t2.data) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.strip_column_names","title":"strip_column_names","text":"<pre><code>strip_column_names() -&gt; None\n</code></pre> <p>strips out all column name string apart from last two sections delimited by dots</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; before = list(t.data.columns)[:3]\n&gt;&gt;&gt; t.strip_column_names()\n&gt;&gt;&gt; after = list(t.data.columns)[:3]\n&gt;&gt;&gt; all(len(c.split('.')) == 2 for c in after)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.time_as_expected","title":"time_as_expected","text":"<pre><code>time_as_expected(mintime: float, maxtime: float) -&gt; bool\n</code></pre> <p>checks that the total length of the tracking data is between mintime seconds and maxtime seconds</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; bool(t.time_as_expected(0.0, 1.0)) # between 0 and 1 second\nTrue\n&gt;&gt;&gt; bool(t.time_as_expected(0.0, 0.1)) # less than 0.1 seconds\nFalse\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.trim","title":"trim","text":"<pre><code>trim(\n    startframe: int | None = None,\n    endframe: int | None = None,\n) -&gt; None\n</code></pre> <p>trims the tracking data object between startframe and endframe</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; _ = t.trim(1, 3)\n&gt;&gt;&gt; int(t.data.index[0]), int(t.data.index[-1])\n(1, 3)\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.filter_likelihood","title":"filter_likelihood","text":"<pre><code>filter_likelihood(threshold: float) -&gt; None\n</code></pre> <p>sets all tracking position values with likelihood less than threshold to np.nan</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.filter_likelihood(0.5)\n&gt;&gt;&gt; bool(np.isnan(t.data.filter(like='.x')).any().any())\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.distance_between","title":"distance_between","text":"<pre><code>distance_between(\n    point1: str, point2: str, dims=(\"x\", \"y\")\n) -&gt; pd.Series\n</code></pre> <p>framewise distance between two points</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; d = t.distance_between('p1', 'p2')\n&gt;&gt;&gt; len(d) == len(t.data)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.get_point_names","title":"get_point_names","text":"<pre><code>get_point_names() -&gt; list\n</code></pre> <p>list of tracked point names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; names = sorted(t.get_point_names())\n&gt;&gt;&gt; set(['p1','p2','p3']).issubset(names)\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.rescale_by_known_distance","title":"rescale_by_known_distance","text":"<pre><code>rescale_by_known_distance(\n    point1: str,\n    point2: str,\n    distance_in_metres: float,\n    dims=(\"x\", \"y\"),\n) -&gt; None\n</code></pre> <p>rescale all dims by known distance between two points</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.rescale_by_known_distance('p1','p2', 2.0)\n&gt;&gt;&gt; t.meta['distance_units']\n'm'\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.generate_smoothdict","title":"generate_smoothdict","text":"<pre><code>generate_smoothdict(\n    pointslists: list, windows: list, smoothtypes: list\n) -&gt; dict\n</code></pre> <p>deprecated, use smooth_all instead</p>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.smooth","title":"smooth","text":"<pre><code>smooth(smoothing_params: dict) -&gt; None\n</code></pre> <p>deprecated, use smooth_all instead</p>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.smooth_all","title":"smooth_all","text":"<pre><code>smooth_all(\n    window: int | None = 3,\n    method: str = \"mean\",\n    *overrides: tuple[\n        list[str] | tuple[str, ...] | str, str, int | None\n    ],\n    dims: tuple[str, ...] = (\"x\", \"y\"),\n    strict: bool = False,\n    inplace: bool = True,\n    smoother=None,\n    smoother_kwargs: dict | None = None\n) -&gt; \"Tracking | None\"\n</code></pre> <p>Smooth all tracked points using a default method/window, with optional override groups.</p> <ul> <li>window/method: default applied to any point without override</li> <li>overrides: zero or more tuples of (points, method, window), where<ul> <li>points: list/tuple of point names (or a single str)</li> <li>method: 'median' or 'mean'</li> <li>window: int (or None to skip smoothing for those points)</li> </ul> </li> <li>dims: coordinate dimensions to smooth</li> <li>strict: require an effective window for every point</li> <li>inplace: mutate or return a new object</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.smooth_all(3, 'mean', (['p1'], 'median', 4))\n&gt;&gt;&gt; 'smoothing' in t.meta\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.interpolate","title":"interpolate","text":"<pre><code>interpolate(\n    method: str = \"linear\", limit: int = 1, **kwargs\n) -&gt; None\n</code></pre> <p>interpolates missing data in the tracking data, and sets likelihood to np.nan uses pandas.DataFrame.interpolate() with kwargs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; t.filter_likelihood(0.5)\n&gt;&gt;&gt; t.interpolate(method='linear', limit=1)\n&gt;&gt;&gt; 'interpolation' in t.meta\nTrue\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx)\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.plot","title":"plot","text":"<pre><code>plot(\n    trajectories=None,\n    static=None,\n    lines=None,\n    dims=(\"x\", \"y\"),\n    ax=None,\n    title=None,\n    show=True,\n    elev=30,\n    azim=45,\n)\n</code></pre> <p>Plot trajectories and static points for this Tracking object. Args:     trajectories: list of point names or dict {point: color_series}     static: list of point names to plot as static (median)     lines: list of (point1, point2) pairs to join with a line     dims: tuple of dimension names (default ('x','y'); use ('x','y','z') for 3D)     ax: matplotlib axis (optional)     title: plot title (default: self.handle)     show: whether to call plt.show() Returns: fig, ax</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from py3r.behaviour.util.docdata import data_path\n&gt;&gt;&gt; with data_path('py3r.behaviour.tracking._data', 'dlc_single.csv') as p:\n...     t = Tracking.from_dlc(str(p), handle='ex', fps=30)\n&gt;&gt;&gt; _ = t.plot(show=False)\n</code></pre>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.save_3d_tracking_video_multi_view","title":"save_3d_tracking_video_multi_view","text":"<pre><code>save_3d_tracking_video_multi_view(\n    out_path: str,\n    lines: list[tuple[str, str]] = None,\n    point_size=40,\n    line_width=2,\n    point_color=\"b\",\n    line_color=\"k\",\n    dpi=150,\n    writer=\"pillow\",\n    startframe=None,\n    endframe=None,\n    xlim=None,\n    ylim=None,\n    zlim=None,\n    robust_percentile=1,\n    invert_z=True,\n)\n</code></pre> <p>Save a 3D animation of tracked points to a video file, with 4 subplots per frame: - azim=0, elev=0, ortho - azim=90, elev=0, ortho - azim=0, elev=90, ortho - azim=45, elev=30, persp Optionally, set axis limits manually or use robust percentiles to ignore outliers. Enforces equal aspect ratio for all axes.</p>"},{"location":"api/tracking/#py3r.behaviour.tracking.tracking.Tracking.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre>"},{"location":"api/tracking_collection/","title":"TrackingCollection","text":""},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection","title":"py3r.behaviour.tracking.tracking_collection.TrackingCollection","text":"<pre><code>TrackingCollection(tracking_dict: dict[str, Tracking])\n</code></pre> <p>               Bases: <code>BaseCollection</code>, <code>TrackingCollectionBatchMixin</code></p> <p>Collection of Tracking objects, keyed by name (e.g. for grouping individuals) note: type-hints refer to Tracking, but factory methods allow for other classes these are intended ONLY for subclasses of Tracking, and this is enforced</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.tracking_dict","title":"tracking_dict  <code>property</code>","text":"<pre><code>tracking_dict\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.loc","title":"loc  <code>property</code>","text":"<pre><code>loc\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.iloc","title":"iloc  <code>property</code>","text":"<pre><code>iloc\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_mapping","title":"from_mapping  <code>classmethod</code>","text":"<pre><code>from_mapping(\n    handles_and_filepaths: dict[str, str],\n    *,\n    tracking_loader,\n    tracking_cls=Tracking,\n    **loader_kwargs\n)\n</code></pre> <p>Generic constructor from a mapping of handle -&gt; filepath using a loader callable.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlc","title":"from_dlc  <code>classmethod</code>","text":"<pre><code>from_dlc(\n    handles_and_filepaths: dict[str, str],\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls=Tracking\n)\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_yolo3r","title":"from_yolo3r  <code>classmethod</code>","text":"<pre><code>from_yolo3r(\n    handles_and_filepaths: dict[str, str],\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls=Tracking\n)\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlcma","title":"from_dlcma  <code>classmethod</code>","text":"<pre><code>from_dlcma(\n    handles_and_filepaths: dict[str, str],\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls=Tracking\n)\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dogfeather","title":"from_dogfeather  <code>classmethod</code>","text":"<pre><code>from_dogfeather(\n    handles_and_filepaths: dict[str, str],\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls=Tracking\n)\n</code></pre> <p>Loads a TrackingCollection from a dict of dogfeather tracking csvs. handles_and_filepaths: dict mapping handles to file paths.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_folder","title":"from_folder  <code>classmethod</code>","text":"<pre><code>from_folder(\n    folder_path: str,\n    *,\n    tracking_loader,\n    tracking_cls: type = Tracking,\n    **loader_kwargs\n) -&gt; TrackingCollection\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_yolo3r_folder","title":"from_yolo3r_folder  <code>classmethod</code>","text":"<pre><code>from_yolo3r_folder(\n    folder_path: str,\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls: type = Tracking\n) -&gt; TrackingCollection\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlc_folder","title":"from_dlc_folder  <code>classmethod</code>","text":"<pre><code>from_dlc_folder(\n    folder_path: str,\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls: type = Tracking\n) -&gt; TrackingCollection\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.from_dlcma_folder","title":"from_dlcma_folder  <code>classmethod</code>","text":"<pre><code>from_dlcma_folder(\n    folder_path: str,\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    tracking_cls: type = Tracking\n) -&gt; TrackingCollection\n</code></pre>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.add_tags_from_csv","title":"add_tags_from_csv","text":"<pre><code>add_tags_from_csv(csv_path: str) -&gt; None\n</code></pre> <p>Adds tags to all Tracking objects in the collection from a csv file. csv_path: path to a csv file with first column: \"handle\" and other columns with tagnames as titles and tagvalues as values</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.stereo_triangulate","title":"stereo_triangulate","text":"<pre><code>stereo_triangulate() -&gt; TrackingCollection\n</code></pre> <p>Triangulate all TrackingMV objects and return a new TrackingCollection. The new collection will have the same grouping as the original.</p>"},{"location":"api/tracking_collection/#py3r.behaviour.tracking.tracking_collection.TrackingCollection.plot","title":"plot","text":"<pre><code>plot(*args, **kwargs)\n</code></pre>"},{"location":"api/tracking_mv/","title":"TrackingMV","text":""},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV","title":"py3r.behaviour.tracking.tracking_mv.TrackingMV","text":"<pre><code>TrackingMV(\n    views: dict[str, Tracking],\n    calibration: dict,\n    handle: str,\n)\n</code></pre> <p>multi-view tracking object for stereo or multi-camera setups can be used as a drop-in replacement for Tracking in TrackingCollection stores dict of view name -&gt; Tracking, calibration, and handle</p>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.views","title":"views  <code>instance-attribute</code>","text":"<pre><code>views = views\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.calibration","title":"calibration  <code>instance-attribute</code>","text":"<pre><code>calibration = calibration\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.handle","title":"handle  <code>instance-attribute</code>","text":"<pre><code>handle = handle\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_views","title":"from_views  <code>classmethod</code>","text":"<pre><code>from_views(\n    filepaths: dict[str, str],\n    handle: str,\n    *,\n    calibration: dict,\n    tracking_loader,\n    **loader_kwargs\n)\n</code></pre> <p>Loads a TrackingMV object from a dictionary of filepaths and a calibration dictionary.</p>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_dlc","title":"from_dlc  <code>classmethod</code>","text":"<pre><code>from_dlc(\n    filepaths: dict[str, str],\n    handle: str,\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    calibration: dict\n)\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_dlcma","title":"from_dlcma  <code>classmethod</code>","text":"<pre><code>from_dlcma(\n    filepaths: dict[str, str],\n    handle: str,\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    calibration: dict\n)\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.from_yolo3r","title":"from_yolo3r  <code>classmethod</code>","text":"<pre><code>from_yolo3r(\n    filepaths: dict[str, str],\n    handle: str,\n    *,\n    fps: float,\n    aspectratio_correction: float = 1.0,\n    calibration: dict\n)\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.stereo_triangulate","title":"stereo_triangulate","text":"<pre><code>stereo_triangulate(invert_z: bool = True) -&gt; 'Tracking'\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.align_ids_by_keypoints","title":"align_ids_by_keypoints","text":"<pre><code>align_ids_by_keypoints(\n    keypoints: list[str], views: list[str] | None = None\n) -&gt; \"TrackingMV\"\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.plot","title":"plot","text":"<pre><code>plot(\n    trajectories=None,\n    static=None,\n    lines=None,\n    dims=(\"x\", \"y\"),\n    ax=None,\n    title=None,\n    show=True,\n)\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name)\n</code></pre>"},{"location":"api/tracking_mv/#py3r.behaviour.tracking.tracking_mv.TrackingMV.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre>"}]}